[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Over Mij",
    "section": "",
    "text": "Hoi,\nLeuk dat je kijkt op deze blog van een rare vogel (een Koolmees bijvoorbeeld). Als je mijn introductie (nog) niet hebt gelezen, dan kan je die hier vinden. Er is alweer een tijdje over heen gevlogen (blijf een vogel), toch verwijs ik graag naar de vervolg plannen van de blog hier.\nDit blog gaat dus over twee passies Artificiele Intelligentie (AI) en biologie. Op dit moment is eerst het plan om een van de beste AI beoefenaars te worden van Nederland. Om dat vervolgens toe te passen in de Biologie met als droom: op een goedkopere manier medicijnen te ontwikkelen. Ik neem jullie mee op dit avontuur.\nDe laatste tijd ligt op Software ontwikkeling. Ondertussen heb ik de eerste ervaringen met Flutter voor het maken van mobiele maar ook web apps. Programmeren in Flutter is zo een fijne ervaring dat ik mij daar graag verder in ontwikkel.\nDaarnaast ben ik ook vooral bezig met Python. Hiermee was ik begonnen omdat het een gemakkelijke taal is en er veel online cursussen zijn over Machine Learning gebruiken die Python gebruiken. Nu ben ik bezig met een App waarmee ik de back-end met FastAPI (een Python package) aan het schrijven ben. Omdat Python veel in de ML wereld wordt gebruikt en ik mij daar in de toekomst weer mee bezig blijf houden ga ik mij daar graag verder in verdiepen.\nAls laatste, het word al minder gebruikelijk om fysieke servers te hebben. Bijna alles gaat nu in de Cloud. Het is een interessante manier van programmeren en eigenlijk zorgt het ervoor dat je alles kan doen wat je maar wilt. Daarom wil ik dit jaar mij graag ook verder ontwikkelen in dit gebied.\nMijn droom is nog steeds om AI, programmeren en biologie te combineren. Maar eerst wil ik deze programmeer fundamenten goed onder de knie hebben.\n\nWat doe ik nu (07JAN23)\nWerk: Consultant bij Navara\n\nProject\n\nRecepten App maken\n\n\n\nBoeken\n\nAyn Rand - Atlas Shrugged\nGerald Jay Sussman en Hal Abelson - Structure and Interpretation of Computer Programs (Programmeren)\n\n\n\nCursussen\n\nBerkeley 61A\nAWS Developer Associate"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "",
    "text": "Hallo, In de vorige post1 hebben is de integration test geschreven. Nu faalt deze test omdat de app nog niet gemaakt is, maar daar gaat in deze post verandering in komen! Maar, omdat ik (zoveel mogelijk) test driven probeer te werken begint deze post opnieuw met tests… Alleen dit keer zijn het Widget tests. Deze tests lijken in eerste instantie veel op de integration test. Het verschil is dat deze tests losse onderdelen, Widgets, testen in plaats van het geheel (wat we doen met de integration test).\nLaten we beginnen!\nPS: Vind de code hier"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#widget-tests",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#widget-tests",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "Widget Tests",
    "text": "Widget Tests\nEen widget test2 is een test wat een onderdeel van de User Interface (UI) test. Hetgeen dat er getest gaat worden is wederom gebaseerd op de ruwe schets (hieronder weergeven). En met de widget test, wordt in dat geval ook dezelfde logica getest (mede doordat de app nog niet zo complex is).\n\nIn onderstaande Widget test zijn de tests in verschillende groepen verdeelt, omdat dit losse Widgets zijn.\nDe eerste groep is de DailyPracticeApp groep, en die test de Widget DailyPracticeApp. Wanneer je deze weergeeft verwacht ik dat de PracticesPage wordt weergeven. De test werkt als volgt:\n\nJe rendert (weergeven van) de Widget met tester.pumtWidget()\nJe zoekt de PracticesPage wordt weergeven met find.byType()\nJe test de verwachting (expect) dat er 1 Widget met het type PracticesPage is gerendert (findsOneWidget).\n\nIn bovenstaande test zit een structuur.\n\nDe test wordt voorbereid (in dit geval door je Widget te renderen)\nJe zoekt iets (de PracticesPage)\nJe test je verwachting\n\nDeze structuur wordt Arrange, Act en Assert genoemd. Al moet ik zeggen dat Arrange en Act in dit geval zijn samengevoegd tot het renderen van de Widget. Een test die deze structuur beter aanhoud zou de volgende kunnen zijn:\n\nJe rendert een Widget met een knop (Arrange)\nJe voert een actie uit, deze actie is op de knop drukken (Act)\nJe verwacht dat onButtonClick (bijvoorbeeld) 1x wordt uitegevoerd (Assert)\n\nJe zult deze structuur in veel tests terug vinden omdat het structurenen van tests de tests leesbaarder maken!\nDe volgende test groep PracticesPage, test ongeveer hetzelfde, maar dan wordt er getest of er een andere Widget gerenderd wordt (PracticesView). Hierna volger er interessantere tests, namelijk de PracticesView groep.\nIn deze groep wordt er namelijk getest of de app titel en alle practices worden gerenderd. Als eerste de app titel, die vindt je door in de AppBar te kijken (een Widget dat bovenaan je mobiele scherm verschijnt). En daarin te zoeken naar de titel ‘Daily Practices’.\nTot slot, wordt er getest of alle practices in de lijst kunnen gevonden. Maar dit heeft ook wat belemmeringen. Normaliter kan je namelijk alleen testen wat er op dat moment op je scherm verschijnt. Daarom gebruiken we net als in de integration tests de scroll functionaliteit. Dat resulteert in de volgende stappen: * Zoek een Scrollable (dat is de lijst) * Controleer of de eerste practice is gerenderd * Scroll door tester.fling() te gebruiken (let op: je moet je scherm dan verversen door tester.pumpAndSettle() aan te roepen) * Test of de laatste practice is gerenderd\nVervolgens wordt dezelfde tactiek gebruikt om te testen of er 1 actieve practice is. Maar hiervoor wordt er aan de actieve practice een speciale Key meegeven waarop gezocht kan worden. Dat wordt gebruikt om net zo lang te scrollen totdat de actieve practice in beeld is.\nDit waren de Widget testen! Op dit moment zullen ze falen en dat kan je zien door\n\nflutter test\n\nuit te voeren! Omdat er verder geen functionaliteit in de basis app hoeft te zitten kan er eindelijk aan de app gewerkt worden!\nPS: Ik heb van een collega geleerd om je groepen en tests op de volgende manier te benoemen:\n\nDe buitenste groep is de class of functie naam die je wilt testen\n\nDan schrijf je in de test wat die moet doen, dan kan je namelijk de groep en de test lezen als 1 zin.\n\nBijvoorbeeld: DailyPracticeApp, renders PracticesPage\n\nMaar wanneer je als in de zin gaat gebruiken, dan maak je een nieuwe groep!\n\nBijvoorbeeld, DailyPracticesApp, (als) je op de knop drukt (dan) render je een succes bericht (de ‘als’ en ‘dan’ schrijf je niet expliciet op)\n\nGroep: DailyPracticesApp\nGroep: je op de knop drukt\nTest: render je een succes bericht\n\n\n\n\nimport 'package:daily_practices_app/features/home/home.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:daily_practices_app/app/app.dart';\n\nvoid main() {\n  group('DailyPracticeApp', () {\n    testWidgets('renders PracticesPage', (tester) async {\n      await tester.pumpWidget(\n        const DailyPracticeApp(),\n      );\n\n      expect(find.byType(PracticesPage), findsOneWidget);\n    });\n\n    group('PracticesPage', () {\n      testWidgets('renders PracticesView', (tester) async {\n        await tester.pumpWidget(\n          const DailyPracticeApp(),\n        );\n\n        expect(find.byType(PracticesView), findsOneWidget);\n      });\n    });\n\n    group('PracticesView', () {\n      Widget buildSubject() {\n        return const MaterialApp(home: PracticesView());\n      }\n\n      testWidgets('renders AppBar with title text', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        expect(find.byType(AppBar), findsOneWidget);\n        expect(\n          find.descendant(\n            of: find.byType(AppBar),\n            matching: find.text('Daily Practices'),\n          ),\n          findsOneWidget,\n        );\n      });\n\n      testWidgets('renders all listitems', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        final listFinder = find.byType(Scrollable);\n        expect(listFinder, findsOneWidget);\n\n        // Verify that the first practice can be found\n        expect(find.text('Sleep eight hours'), findsOneWidget);\n\n        // Scroll to the bottom\n        await tester.fling(\n          listFinder,\n          const Offset(0, -500),\n          10000,\n        );\n        await tester.pumpAndSettle();\n\n        // Verify that the last practice can be found\n        expect(find.text('Deep breathing'), findsOneWidget);\n      });\n\n      testWidgets('one practice should be active', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        final listFinder = find.byType(Scrollable);\n        expect(listFinder, findsOneWidget);\n\n        final activeItemFinder = find.byKey(const ValueKey('ActivePractice'));\n\n        // Find the active practice\n        await tester.scrollUntilVisible(\n          activeItemFinder,\n          500.0,\n          scrollable: listFinder,\n        );\n\n        expect(activeItemFinder, findsOneWidget);\n      });\n    });\n  });\n}"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#de-app",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#de-app",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "De App",
    "text": "De App\n\nmain.dart\nDan is nu toch echt het moment, het bouwen van de app. Omdat testen nu geschreven zijn, is het (hopelijk) vrij gemakkelijk om de “echte” code te schrijvenn. Volgens de testen begin je namelijk met het maken van de DailyPracticesApp. Dit doe je door in main.dart de DailyPracticesApp te runnen met runApp().\nEven terug, main.dart en runApp() zijn nieuwe termen. Waarvoor dienen ze eigenlijk?\nWanneer je app start moet het ergens beginnen, dat is je main.dart en daarin de main() functie. Dus wanneer je de app opent, is de main() functie het eerste wat uitgevoerd wordt! Ok, en runApp()? Daarvoor is het belangrijk om te weten hoe Flutter op de achtergrond een app opbouwt. De term Widget is al een aantal keer voorbij gekomen en in Flutter zijn Widgets erg belangrijk. Zo belangrijk dat Flutter alleen maar Widgets kent! En uit deze Widgets onstaat een Widget Tree (zelfs 3 afzonderlijke trees^LINK NAAR VIDEO). Het probleem is dat een boom ergens moet beginnen. Daarvoor zorgt runApp(). Deze functie maakt de app die je uitvoert (in dit geval DailyPracticeApp() wat een Widget is) de root van de Widget Tree. Daarna kan je app zoveel Widgets toevoegen aan de Tree als je maar wilt!\nimport 'package:daily_practices_app/app/app.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DailyPracticeApp());\n}\n\n\napp.dart\nWanneer de DailyPracticesApp aan de Root is toegevoegd kan je de MaterialApp3 maken. Dit is een handige Widget die veel voor je doet (zie de documentatie voor verdere info). In dit geval zijn er themas mee gegeven voor de kleuren en een home page! Dat is de PracticesPage.\nimport 'package:daily_practices_app/features/home/home.dart';\nimport 'package:flutter/material.dart';\nimport 'package:daily_practices_app/theme/theme.dart';\n\nclass DailyPracticeApp extends StatelessWidget {\n  const DailyPracticeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: FlutterPracticesTheme.light,\n      darkTheme: FlutterPracticesTheme.dark,\n      home: const PracticesPage(),\n    );\n  }\n}\n\n\nhome.dart\nIn de PracticesPage wordt de PracticesView gerenderd (het is de bedoeling dat er nog andere code bijkomt). In de PracticesView wordt er een Scaffold Widget4 aangemaakt waardoor we een titel kunnen toevoegen (AppBar5) en een ListView6 waarin alle practices aan een lijst toegevoegd kunnen worden. De practices zijn Cards7 en 1 van de practices is nu actief (dat wordt voor nu bepaald door een willekeurig getal; code regel 119).\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\n\nconst practices = <Map<String, dynamic>>[\n  {\n    'id': 1,\n    'practice': 'Sleep eight hours',\n  },\n  {\n    'id': 2,\n    'practice': 'Eat two meals instead of three',\n  },\n  {\n    'id': 3,\n    'practice': 'No TV (or YouTube)',\n  },\n  {\n    'id': 4,\n    'practice': 'No junk food',\n  },\n  {\n    'id': 5,\n    'practice': 'No complaining for one whole day',\n  },\n  {\n    'id': 6,\n    'practice': 'No gossip',\n  },\n  {\n    'id': 7,\n    'practice': 'Return an e-mail from five years ago',\n  },\n  {\n    'id': 8,\n    'practice': 'Express thanks to a friend',\n  },\n  {\n    'id': 9,\n    'practice': 'Watch a funny movie or a stand-up comic',\n  },\n  {\n    'id': 10,\n    'practice': 'Write down a list of ideas. The ideas can be about anything',\n  },\n  {\n    'id': 11,\n    'practice':\n        'Read a spiritual text. Any one that is inspirational to you. The bible, the Tao te Ching, anything you want',\n  },\n  {\n    'id': 12,\n    'practice':\n        'Say to yourself when you wake up, \"I am going to save a life today. Keep an eye out for that life you can save',\n  },\n  {\n    'id': 13,\n    'practice': 'Take up a hobby. Do not say you do not have time',\n  },\n  {\n    'id': 14,\n    'practice':\n        'Write down your entire schedule. The schedule you do everyday. Cross out one item and do not do that anymore',\n  },\n  {\n    'id': 15,\n    'practice': 'Suprise someone',\n  },\n  {\n    'id': 16,\n    'practice': 'Think of ten people you are grateful for',\n  },\n  {\n    'id': 17,\n    'practice':\n        'Forgive someone. You do not have to tell them. Just write it down on a piece of paper and burn the paper (or throw it away)',\n  },\n  {\n    'id': 18,\n    'practice': 'Take the stairs instead of the elevator',\n  },\n  {\n    'id': 19,\n    'practice':\n        'When you find yourself thinking of that special someone who is causing you grief, think very quietly, \"No\". If you think of him and (or?) her again, think loudly, \"No!\" Again? Whisper, \"No!\" Again, say it. Louder. Yell it. Louder. And so on',\n  },\n  {\n    'id': 20,\n    'practice': 'Tell someone every day that you love them',\n  },\n  {\n    'id': 21,\n    'practice': 'Do not have sex with someone you do not love',\n  },\n  {\n    'id': 22,\n    'practice': 'Shower. Scrub. Clean the toxins of your body',\n  },\n  {\n    'id': 23,\n    'practice':\n        'Read a chapter in a biography about someone who is an inspiration to you',\n  },\n  {\n    'id': 24,\n    'practice': 'Make plans to spend time with a friend',\n  },\n  {\n    'id': 25,\n    'practice':\n        'If you think, \"Everything would be better of if I were death\" then think. \"That is really cool. Now I can do anything I want and I can postpone this thought for a while, maybe even a few months.\" Because what does it matter now? The planet might not even be around in a few months',\n  },\n  {\n    'id': 26,\n    'practice': 'Deep breathing',\n  },\n];\n\nfinal activePractice = Random().nextInt(26) + 1;\n\nclass PracticesPage extends StatelessWidget {\n  const PracticesPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const PracticesView();\n  }\n}\n\nclass PracticesView extends StatelessWidget {\n  const PracticesView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Daily Practices'),\n      ),\n      body: ListView.builder(\n        padding: const EdgeInsets.all(8),\n        itemCount: practices.length,\n        itemBuilder: (BuildContext context, int index) {\n          if (index == activePractice) {\n            return Card(\n              key: const Key('ActivePractice'),\n              elevation: 3,\n              color: Theme.of(context).colorScheme.primary,\n              child: ListTile(\n                leading: CircleAvatar(\n                  backgroundColor: Colors.white,\n                  child: Text(\n                    practices[index]['id'].toString(),\n                  ),\n                ),\n                title: Text(\n                  practices[index]['practice'],\n                  style: const TextStyle(\n                    color: Colors.white,\n                  ),\n                ),\n              ),\n            );\n          } else {\n            return Card(\n              elevation: 3,\n              child: ListTile(\n                leading: CircleAvatar(\n                  backgroundColor: Theme.of(context).colorScheme.primary,\n                  child: Text(practices[index]['id'].toString()),\n                ),\n                title: Text(practices[index]['practice']),\n              ),\n            );\n          }\n        },\n      ),\n    );\n  }\n}\nAls je dan nu naar main.dart navigeert en op de play knop drukt zal je app starten. Voor voorbeelden om je app te starten, kan je hier kijken duidelijke uitleg vinden.\nDit was de eerste versie van de app! Alleen het is nog niet volgens de MVP, daarvoor moet de app namelijk iedere ochtend een notificatie geven. Hoe je dat kunt doen zal ik gaan omschrijven in de volgende post.\nTot dan!"
  },
  {
    "objectID": "posts/2022-06-07-Een-nieuwe-stap/index.html",
    "href": "posts/2022-06-07-Een-nieuwe-stap/index.html",
    "title": "Een Nieuwe Stap",
    "section": "",
    "text": "Een Tijdje Geleden\nHet is alweer een tijdje geleden dat ik voor het laatste iets op de blog geschreven heb. Toen ik begon als Machine Learning (ML) Engineer was ik vooral daar mijn tijd aan kwijt, zodat ik mij zo goed mogelijk kon ontwikkelen en een mooi product kon maken. Ik denk dat ik mag zeggen dat beide zijn gelukt. Het gevolg daarvan is dat ik een volgende stap mag zetten naar een nieuwe werkgever waar ik ontzettend naar uit kijk! Voordat ik daar zou gaan beginnen hadden mijn vriendin en ik drie weken vakantie genomen, waarin we veel rust hebben gepakt. Ook heb ik kunnen nadenken over activiteiten naast werk, zoals deze blog. Hier had ik, toen ik begon, bepaalde ideeën over, maar deze zijn nu veranderd. In deze post wil ik dat toelichten en hopelijk lijkt het jullie interessant om met mij een nieuw avontuur te beleven.\n\n\nHet Nieuwe Idee\nTijdens de vakantie heb ik een nieuw idee bedacht om het voor mezelf makkelijker te maken om meer te gaan bloggen, namelijk op projectbasis. Zelf programmeer ik namelijk ook in projecten en ik denk dat dit zal helpen met het schrijven van een blogpost. Daarbij komt ook dat het proces van een nieuw project niet vaak beschreven wordt (althans ik heb dit naast standaard tutorials niet veel gevonden). Wellicht is het voor anderen ook waardevol om via deze weg meer te leren over het maken van een nieuw project.\n\n\nDe Planning\nVoor nu heb ik een voorlopige planning gemaakt maar deze staat zeker niet vast (Ik schrijf nu namelijk op de Note Air 2, en het zou super handig zijn wanneer handgeschreven notities automatisch worden omgezet naar een Jupyter Notebook. Aan dit project ben ik meteen begonnen wat de planning na 2 dagen al overhoop gooide :)). Maar toch probeer ik mij aan deze planning te houden:\n\n\nAutomatisch handgeschreven tekst naar Jupyter Notebook\nAndroid app maken (Minimum Viable Product: MVP)\n\nFunctioneel programmeren Python module schrijven (op basis van het boek Grocking Simplicity)\nAnki Add-on (MVP)\nRecepten Web-App (MVP)\n\nDaarna wordt het waarschijnlijk het verbeteren van de MVPs naar nieuwere versies. Maar zoals gezegd, bestaat er een kans op verschuivingen in de planning en tussenkomende projecten.\n\n\nProces\nOok wil ik zoveel mogelijk via DevOps (hierover later meer!) principes gaan werken om zo te laten zien hoe je in de praktijk (wat ik nu weet) zou kunnen werken. Zelf heb ik namelijk ondervonden dat dit nauwelijks wordt uitgelegd. Ik geloof dat werken met DevOps principes veel voordelen heeft maar dat ik mij hier nog veel in kan verbeteren. Daarom ga ik dat in eigen projecten toepassen en hoor ik ook graag wat jullie zouden doen!\nHopelijk geeft dit een duidelijk beeld en lijkt het jullie leuk om te volgen. Bedankt voor het lezen en hopelijk tot de volgende keer!\nFijne dag!\nMees"
  },
  {
    "objectID": "posts/2022-09-27-Flutter-app-deel-3-CI-nog-geen-CD/index.html",
    "href": "posts/2022-09-27-Flutter-app-deel-3-CI-nog-geen-CD/index.html",
    "title": "Een Flutter App - Deel 3 - CI Nog Geen CD",
    "section": "",
    "text": "Intro\nHallootjes,\nwelkom bij de volgende stap in het proces om een Flutter app te maken. In de vorige post heb ik de app-structuur bepaald, maar voordat wij daaraan beginnen gaan we eerst een Continuous Integration (CI) pipeline opzetten. Deze pipeline zorgt ervoor dat wanneer er nieuwe code wordt gepushed er automatisch wordt gecontroleerd of de bestaande code en app nog naar behoren werken. Dit doe je door tests te schrijven die vervolgens worden uitgevoerd door je pipeline.\nPS: Hier is de Github repository\nIn Flutter heb je drie soorten tests: integration, widget en unit tests. Laten we eerst kijken naar de integration tests. Dit zijn tests om de gehele app te testen. Deze test repliceert het gedrag van een gebruiker en is wat mij betreft daarom ook de belangrijkste soort test. Deze tests moeten altijd werken om te garanderen dat je app hetzelfde functioneert. Ten tweede, widget test: dit zijn tests (zoals de naam al doet vermoeden) om widgets, onderdelen van de User Interface (UI) te testen. En als laatste unit tests. Deze tests zijn handig om de werkzaamheid van losse functies of classes te testen. En deze tests zouden zo simpel moeten zijn dat ze zelfs op de pc van je oma kunnen draaien (ben de bron van deze quote kwijt). Maar waarom testen wij eigenlijk?\nEr zijn een legio voordelen aan het automatisch testen van code, zoals het besparen van kosten (omdat je (minder) manueel hoeft te testen), sneller developen en deployen en een hogere code qualiteit. Lees voor nog meer voordelen en adviezen over automatisch testen eens The DevOps Handbook. Maar de belangrijkste van alles is het korter maken van de feedback loop. Als developer is er namelijk niets frustrerender dan dat je code hebt gemaakt waarna je maanden later hoort dat er iets niet werkte. Het zou veel beter zijn om direct te weten dat er iets niet meer werkt zodat je na jou aanpassing/toevoeging het probleem direct kan oplossen en daar dan ook van te leren. In tegenstelling tot lang wachten want dan weet je niet eens meer waarom je dat stukje code hebt geschreven laat staan hoe je het kunt oplossen.\n\n\nGithub Actions\nVoor deze CI pipelines ga ik Github Actions gebruiken. Het voordeel hiervan is dat de code, het project board en de pipelines allemaal in één omgeving staan (namelijk Github). Daarnaast zijn Github Actions voor Publieke repositories gratis (voor Private repositories heb je een aantal gratis minuten per maand en daarna betaal je voor de minuten die je extra gebruikt)! Github Actions heeft zogeheten Runners (een virtuele machine die je pipeline uitvoert) met verschillende Operation Systems (OS). Omdat je geen Android of IPhone emulator op een Linux machine kunt draaien, gebruiken we daarvoor macOS runners (let op! in private repos kunnen de kosten van deze runners snel oplopen! Ze zijn namelijk 10x zo duur). Deze emulators zijn nodig om de integratie tests uit te voeren. Maar laten we eerst de eenvoudige tests bespreken: de unit en widget tests.\n\n\nUnit en Widget Tests\nVoor de Unit en Widget tests heb je weinig nodig. Eigenlijk alleen een computer met Flutter geïnstalleerd en dan kan je gemakkelijk de volgende command uitvoeren:\n\nflutter test\n\nDeze stappen uit voeren met een Github Action zijn ook gemakkelijk! Als eerste moet je Flutter installeren. Op de Github Marketplace heeft een gebruiker een Action gedeeld waarmee je de gewenste Flutter versie kan installeren. Vervolgens installeer je de packages en dan test je (voorbeeld hieronder). Deze YAML bestander sla je op onder de folders .github/workflows en deze workflow zal af gaan iedere keer dat er code naar main wordt gepushed.\nname: Flutter Unit And Widget Tests\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      - name: Analyze the code\n        run: flutter analyze\n\n      - name: Run unit tests with coverage\n        run: flutter test --coverage\nVoorbeeld is gebaseerd op: Run Flutter tests using GitHub Actions and Codecov\n\n\nWeb Integration Tests\nDe volgende makkelijk op te zetten tests zijn web integratie testen. Deze draaien namelijk met een Chrome Driver die je ook op Linux machines kunt installeren. Hieronder is een voorbeeld voor een Github Workflow dat web integration tests uitvoert. Maar voordat je deze kunt uitvoeren, heb je een klein Dart bestandje nodig die de integrationDriver start (zie hieronder) (klik hier voor extra informatie). Vervolgens kan je met de command:\n\nflutter drive\n\nde web integration test starten. Het nadeel is wel dat je het bestand dat je wilt testen moet specificeren. Dat resulteert in één groot integration test bestand. Zelf vind ik het fijner om tests te verdelen in verschillende bestanden, maar daar is helaas voor deze web integration tests nog geen oplossing voor.\nname: Flutter Web Integration Tests\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      - name: Start Chromedriver\n        run: chromedriver --port=4444 &\n\n      - name: Run Web integration test\n        run: flutter drive --driver=test_driver/integration_test.dart --target=integration_test/integration_test.dart -d web-server\nVoorbeeld is gebaseerd op: Run Flutter Integration Tests in GitHub Actions\n\n\nIPhone Integration Tests\nNu zijn we aangekomen bij de complexere integration tests (en ook bij de duurdere wanneer je een Private repo hebt). Deze tests worden namelijk uitgevoerd op een macOS runner. Ook zit er een klein stukje code in de Github Action dat ervoor zorgt dat je de juiste UDID krijgt van de IPhone Emulator. Met deze UDID kan je dan succesvol de integration testen uitvoeren (zie voorbeeld Action hieronder). In het geval van deze integration tests kun je de folder waar de tests zich bevinden aangeven i.p.v. een bestand zoals met de web integration tests. Hierdoor kan je de tests wel verdelen in verschillende bestanden.\nname: flutter iphone integration test\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  iphone_integration_test:\n    # NOTE: Running on macOS\n    runs-on: macOS-latest\n\n    # The device name is saved in an environment variable\n    # we use this environment variable to search for the device UDID\n    env:\n      device: 'iPhone 13 Simulator \\(16.0\\)'\n\n    steps:\n      # We list the simulators for debugging purposes\n      # when the device in the environment variable is not in this list\n      # we have to change it to one that is in the list\n      - name: List all simulators\n        run: xcrun xctrace list devices\n\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      # We first get the UDID of the device with an awk command\n      # Then we boot that device and use that device for the integration test with the -d flag\n      - name: Get UDID device, Start Simulator and Connect flutter\n        run: |\n          UDID=$(xcrun xctrace list devices | awk -F \" \" '/${{ env.device }}/ && length($5) > 1 {print $5}' | tr -d '()')\n          echo $UDID\n          xcrun simctl boot \"${UDID:?No Simulator with this name found}\"\n          flutter test integration_test -d $UDID\nVoorbeeld is gebaseerd op: Run Flutter Driver tests on GitHub Actions\n\n\nAndroid Integration Tests\nOok de Android integration tests kan je enkel draaien op een macOS runner. Omdat Android Gradle gebruikt om je app te builden (zo heet dat) heb je Java versie 11 of hoger nodig. Wanneer je die actie hebt uitgevoerd installeer je wederom Flutter. Als laatste gebruiken we een actie van ReactiveCircus om een Android Emulator te starten. Aan deze actie moeten de minimum api-leven en het uit te voeren script worden mee gegeven.In dit geval is het script een losse command.\nname: flutter android integration test\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  android_integration_test:\n    runs-on: macOS-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # We need atleast Java 11 or Higher to build your app with this version of Gradle\n      # So we use this Marketplace Action to install it\n      - name: Setup Java JDK\n        uses: actions/setup-java@v3.5.0\n        with:\n          distribution: \"zulu\"\n          java-version: \"11.x\"\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      # Use a Github Action from the Marketplace to start an Android Emulator with api-level 23\n      - name: Start Emulator And Start Tests\n        uses: reactivecircus/android-emulator-runner@v2\n        with:\n          api-level: 23\n          script: flutter test integration_test\nNu de verschillende pipelines zijn opgezet push ik dit naar Github en zullen deze de tests draaien wanneer ik nieuwe code naar Github push. Daarvoor zijn natuurlijk nog wel de afzonderlijke unit, widget en integratie tests nodig! Dus deze zullen snel volgen.\nDit was het voor nu, tot de volgende keer en geniet van de herfst :).\nMees"
  },
  {
    "objectID": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html",
    "href": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html",
    "title": "Een Flutter App - Deel 2 - Voorbereiden App Structuur",
    "section": "",
    "text": "Hallo allemaal!\nLeuk dat jullie hier weer zijn om dit project te volgen. In deze post neem ik jullie mee in de planning voor de codestructuur van de app die ik aan het maken ben. Omdat dit mijn eerste eigen Flutter project is, neem ik veel informatie over van andere bronnen. Hierdoor leer je op een andere manier (dan je automatische piloot) kijken naar het opzetten van projecten. En wanneer dit bevalt kan je dat uiteraard inbouwen in je automatische werkwijze voor je volgende projecten!\n\nStappenplan App maken\nIn de vorige post van dit project1 heb ik de vereisten vastgesteld. In die fase beschreef ik wat de app moet hebben om de klant haar problemen op te lossen. Maar op technisch vlak is dan nog niets bepaald. Deze fase gaat over het technische vlak, namelijk wat zijn de technische stappen die nodig zijn om de app op te leveren. Voor dit project heb ik grofweg de App Development Workflow van Code with Andrea2 aangehouden.\nOver de eerste twee stappen, Design en Database/Backend, kan ik kort zijn. Het Design zal een simpele lijstweergave zijn (de standaard ingebouwd in Flutter). En voor versie 1 (V1) hebben we gezegd: hardcoded practices (dus geen database) en er is ook geen backend nodig. Dat waren de eerste twee stappen al, maar de volgende stap is een stuk uitdagender!\nDe derde stap is namelijk het bepalen van de app architectuur. Nu is dit dus mijn eerste Flutter project en heb ik nog geen goed idee over wat de handigste app structuur voor een Flutter project is. Gelukkig werk ik ondertussen wel aan een andere Flutter app waarin we Flutter Blocs gebruiken. En in de voorbeelden van Flutter Blocs kwam ik een structuur tegen die mij aansprak3. Hieronder heb ik diezelfde structuur vertaald naar de app die ik aan het maken ben.\n\n\nOpmerking: Onderstaande alinea’s zijn technisch, maar daar ontkom je niet aan bij het bepalen van de app architectuur :).\n\nDe Data Layer is, zoals de naam van de layer ook omschrijft, de connectie naar je onbewerkte data. Deze wil je het liefste zo generiek mogelijk houden en is vaak een simpele API om CRUD (Create, Read, Update, Delete) operaties uit te voeren. In de app Data Layer zitten twee componenten, de Daily Practices API en Hardcoded Daily Practices API. De eerstgenoemde is de generieke interface (een soort van blauwdruk van je verschillende implementaties). Als V1 heb ik vastgesteld dat de Daily Practices hardcoded en niet aanpasbaar zijn. Daarom hebben deze APIs voor V1 alleen een leesoperatie nodig. De specifieke implementatie hiervan wordt gedaan in de Hardcoded Daily Practices API.\nDe volgende laag is de Domain Layer. Hierin koppel je de data APIs in een repository. Je voegt hieraan zogeheten business rules toe om bijvoorbeeld data te filteren of in een bepaalde structuur door te geven aan je Blocs in de feature layer.\nDe repository layer geeft de data dus door aan je Blocs in de Feature Layer. Hierdoor fungeert je Bloc als brug tussen de data en de (User Interface) UI in je app. De Bloc bevat je business (b) logic (loc). Afhankelijk van acties van de gebruiker vraagt de Bloc data op uit (mogelijk verschillende) repositories. Hierdoor verandert de state van je Bloc. Deze verandering wordt opgepikt door de UI en daardoor past de UI van de app zich aan. Het grootste voordeel van deze structuur is dat de business logic en UI gescheiden zijn. Dit reduceert coupling en daardoor zijn de afzonderlijke onderdelen van je app in isolatie te testen en te gebruiken!\nNadat de app architectuur is bepaald, kan je samen met de vereisten een project board maken. In eerste instantie gebruikte ik Trello maar later dacht ik dat het handiger zou zijn om alles op 1 plek te hebben. Daarom ben ik overgestapt naar Github Projects4. Ik heb geprobeerd om het zo volledig mogelijk te maken, maar het zal vast zijn dat ik zaken ben vergeten. Dus dat vul ik in wanneer ik dat tegenkom. Het project board heb ik opgedeeld in verschillende onderwerpen (Test, UI, Flutter en CI/CD). En daaronder heb ik dan de verschillende taken bedacht en aangemaakt. Toen dat gedaan was kon ik beginnen aan de volgende stap, de CI/CD pipeline.\nDoor te beginnen met de CI/CD pipeline kan je zo vroeg mogelijk beginnen met testen. Omdat alles op Github staat gebruiken we in dit geval Github Actions voor onze (in eerste instantie niet CD) CI pipeline. De specifieke implementatie van de Github Actions zal ik in een volgende post vertellen.\nDe laatste stap is het uitvoeren van de taken op je project board! Ondertussen ben ik al begonnen. Doordat ik bij mijn vorige projecten een andere werkwijze aanhield, was even wennen. Maar eenmaal in het ritme gekomen ging alles voortvarend! Ik heb veel geleerd en veel van de taken zijn voltooid. Op dit moment ben ik vastgelopen op het notificatie deel maar wanneer dat werkt is V1 zo goed als af! Hopelijk lukt dat binnenkort!\nTot de volgende keer :)\nMees\n\n\n\n\n\nFootnotes\n\n\nAndroid App in Flutter Deel 1 - Voorbereiding↩︎\nCode With Andrea App Development Worklfow↩︎\nBloclibrary - Flutter Todos Tutorial↩︎\nGithub Project Board - Flutter App↩︎"
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "",
    "text": "In deze post neem ik jullie mee met de voorbereidingen van het maken van een Android app. Nu zie ik de vraagtekens in je hersenspinsels verschijnen, want je hebt gelijk: een Android app kan van alles zijn. Daarom is de eerste stap bij het maken van een stuk software, zoals een app, belangrijk om te bepalen wat de gebruiker (of klant) wilt. Specifieker nog: welk probleem wil de gebruiker verholpen zien worden?\nIn een team op de werkvloer wordt deze vraag vaak in kaart gebracht door de product owner. Als product owner werk je naar een bepaald doel (bijvoorbeeld 10% meer omzet) van het bedrijf en dit doe je door je software te maken naar de wensen van je (potentiële) gebruikers. Vervolgens zet je deze wensen om in software features (of user stories) en splits je deze op in kleine taken. Daarna buigt het development team zich erover om de technische kant vorm te geven en weer te verdelen in taken. Deze taken worden op een sprint (vaak een periode van 1 - 4 weken) gezet om af te ronden. Door dit proces blijf je altijd werken aan taken die er toe doen voor de klant.\nAanvulling: Tegenwoordig is er wel eens kritiek op bovenstaande aanpak en zou het beter kunnen zijn om het development team zelf de wensen van klanten in kaart te laten brengen. Hierdoor kan het development team rechtstreeks de klant helpen in plaats van te communiceren met een tussenpersoon.\nHet makkelijke aan een eigen project is dat je zelf de klant bent. In dit geval heb ik een probleem en deze wil ik oplossen. Daardoor is het relatief eenvoudig om het probleem vast te stellen, namelijk: er is geen makkelijk te gebruiken Android app om een lijst van taken aan te maken en van deze lijst iedere ochtend 1 willekeurige taak als notificatie binnen te krijgen. (misschien bestaat zo een app wél al, maar ik wil ook graag leren hoe je aan app maakt! :)). Nu dit probleem duidelijk is kan de product owner (wederom ikzelf, ik heb nog niemand aan kunnen nemen door de krapte op de arbeidsmarkt) aan de user stories beginnen.\nWanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen."
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-mvp",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-mvp",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "De MVP",
    "text": "De MVP\nWanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen.\n\n\n\n\n\n\n\nMVP\nVolgende Versie\n\n\n\n\nLijst met hardcoded practices\nLijst dynamisch kunnen aanpassen en opslaan in een database\n\n\n1 willekeurige practice van bovenstaande lijst pakken\nTijd van de notificatie en hoeveel notificaties aanpasbaar maken\n\n\nBovenstaande practice als notificatie geven\nWillekeur als optie kunnen aanvinken\n\n\nNiet 2x dezelfde notificatie achter elkaar\nPractice voor de dag weergeven wanneer je de app opent\n\n\nAlles met unit en functionele tests\n\n\n\nCI/CD pipeline\n\n\n\nVersie controle (Git)\n\n\n\n\nDeze vereisten worden dan door het technische team in taken verdeeld om dit technisch op te lossen. Het is dan fijn wanneer de taken zo klein mogelijk zijn, zodat je iedere dag werkende (en geteste) code kan toevoegen aan je project en je niet hoeft te werken in branches. Belangrijk hierbij is dat de taken zichtbaar zijn, zodat je (bijvoorbeeld) de volgende vragen kunt beantwoorden: Waar wordt aan gewerkt? Loopt er een taak vast? Dit zorgt er mede voor dat je de obstakels kunt oplossen of verbeteren, waardoor je in het vervolg soortgelijke taken sneller kan afronden en daarmee ook sneller de gebruiker (die vaak ongeduldig zijn) kan helpen!"
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-devops-principes-in-dit-project",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-devops-principes-in-dit-project",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "De DevOps principes in dit project",
    "text": "De DevOps principes in dit project\nZoals in de vorige post uitgelegd wil ik mij met ieder project ook bezig houden met de DevOps principes (om daar beter in te worden). Nu voel ik mij niet geschikt om DevOps samen te vatten, maar toch probeer ik het: “DevOps is een werkwijze welke het doel heeft om zo snel en goed mogelijk problemen op te lossen van een gebruiker (met software)”. Een voorbeeld daarvan is de taken zichtbaar maken (zoals hierboven beschreven). Maar er zijn ook vele andere manieren om het DevOps doel te bereiken (daar zijn verschillende boeken over bijvoorbeeld Accelerate van Nicole Forsgen en The DevOps Handbook van Gene Kim). De manieren in dit project om op de DevOps manier te werken wil ik hier graag herhalen:\n\nVergaar en implementeer klant feedback: maak een MVP dat de klant zo snel mogelijk kan beoordelen en jij daardoor kan aanpassen.\nAlles in versie controle (ook configuratie bestanden!)\nCI/CD pipeline. Dat betekent in het kort: na iedere code incheck dat er automatisch testen worden uitgevoerd en wanneer deze testen succesvol zijn uitgevoerd dat deze nieuwe code automatisch in de live software komt.\nWerk in kleine batches/taken opdelen. Het liefste in taken die maximaal in 1 dag af te ronden zijn. Hierdoor hoef je niet in branches te werken.\nMaak je werk zichtbaar! Zelf gebruik ik nu een Trello board (dit ga ik misschien nog veranderen) waarin ik taken kan slepen van todo naar in progress en dan naar done.\n\nEr zijn nog veel meer principes, maar voor dit project focus ik mij op bovenstaande punten.\nVoordat ik deze post afrond wil ik nog melden dat dit de eerste keer is dat ik een android app maak. Dat betekent dat ik op de afgelopen tijd vooral bezig was met het leren van Kotlin voor Android apps. Hiermee ben ik nu klaar. Daarnaast ben ik ook bezig geweest met Flutter. Met Flutter kan je gemakkelijk multi-platform apps maken, wat het een interessante tool maakt. Daarom wil ik deze eerste app met Flutter schrijven om daar beter in te worden.\nTot de volgende keer!\nGeniet van vandaag :)\nMees"
  },
  {
    "objectID": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html",
    "href": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html",
    "title": "Side Project - Combining FastAPI and nbdev",
    "section": "",
    "text": "Introduction\n\nNote for frequent readers: this blogpost is written in English since I want to share this post with the fastai community\n\nHello everyone,\nIn this post I won’t discuss Flutter as you are used to, but I will go back to my roots: Python. Python is an extremely convenient lanuage since it has hundruds of usefull packages which make you more productive. Here, I will share two awesome packages nbdev1 and FastAPI2. Furthermore. I will show you how to combine these two packages to create an awesome documented web-API.\n\n\nFastAPI\nFastAPI3 is a package that is useful to create a high performing and automatically documented web API.\n\nThe FastAPI documentation is better in explaining its greatness but I will try to summarize it.\n\nFastAPI is based on two packages. Firstly, Starlette4, a lightweight Asynchronous Server Gateway Interface (ASGI) framework. Secondly, Pydantic5, a data validation package using Python type annotations. Due to the async capabilities its fast and do to Pydantich and Python’s type annotations it helps you speed up your API development and it helps you preventing errors. And, as icing on the cake, it autogenerates API documentation (OpenAPI/Swagger and Redoc). However, it does not cover code documentation, which is necessary to cooperate efficiently with other developers. That is one of the strengths of using Notebook development with nbdev.\n\n\nnbdev\nI think that most Python developers have use Jupyter Notebooks. And I also think that the majority of that group liked the experimental workflow that Notebooks facilitate. However, developing in a Notebook has many pitfalls such as: * Since Notebooks are JSON files with changing Metadata it is hard to use it with version control practices * It does have reproducibility issues (for example, running code cells in the correct order) * Difficult to test\nBut fear not, nbdev6 is our saviour.\nNbdev improves developing in Notebooks by extracting code into Python modules (which already solve the Notebooks version control horrer and order of code execution)! Additionally, using Notebooks you can let your creative genius fly and do all the exploratory development you want since your findings are easily integrated in a module. Lastly, your Markdown cells is used to create documentation automatically! In my opinion, this solves a massive problem in software engineering, namely proper code documentation. You are now able to explain your code choices with text, images, links, graphs you name it!\n\nFor example, whenever you optimize a piece of code, you can now document it together with your code by showing a graph of the old vs new situation.\n\nIn theory, when combining FastAPI and nbdev you can now create code which is fully documented for your fellow programmers and an API which is documented by autogenerated FastAPI docs. But does it work in practice?\n\n\nCombining FastAPI and nbdev\nThe answer is YES! In this Github repository7 I have created a small and simple proof of concept. As you can see in the Notebooks, I have documented how to use the repository in the Notebooks itself.\nI think it is amazing to be able to create a fast web API using an experimental workflow with the ability to add proper documentation.\nLastly, you can even test your endpoints if you alter nbdevs CI Github Action slightly8. With the small change, it starts the web API in the Github action before running the tests :).\nI want to encourage you to give nbdev a try for your next project. You can share your experiences and ask question on this forum9.\nThank you for reading and have fun programming!\nMees\n\n\n\n\n\nFootnotes\n\n\nhttps://nbdev.fast.ai/↩︎\nhttps://fastapi.tiangolo.com/↩︎\nhttps://fastapi.tiangolo.com/↩︎\nhttps://www.starlette.io/↩︎\nhttps://pydantic-docs.helpmanual.io/↩︎\nhttps://nbdev.fast.ai/↩︎\nhttps://github.com/MeesMolenaar/fastapi-nbdev↩︎\nhttps://github.com/MeesMolenaar/fastapi-nbdev/blob/main/.github/workflows/test.yaml↩︎\nhttps://forums.fast.ai/c/nbdev/48↩︎"
  },
  {
    "objectID": "posts/2021-05-26-Eerste-blog-post/index.html",
    "href": "posts/2021-05-26-Eerste-blog-post/index.html",
    "title": "Welkom op CabbageMees!",
    "section": "",
    "text": "Hoi,\nMijn naam is Mees en sommige zullen zeggen dat ik een rare vogel ben (een koolmees bijvoorbeeld). In 2020 heb ik mijn Life Science & Technology diploma van de Universiteit Leiden behaald. Nu wil ik deze kennis over de biologie verbinden met een andere passie van mij, namelijk programmeren en meer specifiek Artificiële Intelligentie (AI). Via deze blog wil ik jullie graag op de hoogte houden van mijn bezigheden.\nMaar eerst nog even terug naar waar het allemaal begon. Toen ik nog jonger en kleiner was dan nu, was het mijn droom om een middel te vinden tegen kanker. Dat was voor mij de reden om, na de middelbare school, Life Science & Technology te gaan studeren. Tijdens de studie kwam ik tot de conclusie dat het laboratorium niks voor mij was en dat ik op deze manier nooit een medicijn zou uitvinden. Dit was een enorme teleurstelling, maar gelukkig kwam ik er snel achter dat je op veel meer manieren bij kan dragen aan het ontwikkelen van medicijnen. Zo ben ik in aanraking gekomen met AI.\nDe eerste kennismaking was tijdens het vak computationele medicijn ontwikkeling (gegeven door prof. dr. ir. Fraaije). Tijdens deze colleges bespraken wij bijvoorbeeld Quantitative Structure-Activity Relationship (QSAR), een machinaal leren (een vorm van AI) techniek om te voorspellen wat voor eigenschappen een molecuul heeft (zoals elektronegativiteit). Dit sprak erg tot mijn verbeelding. En zo begon het fantaseren over een computer programma wat alles weet van het menselijk lichaam en van een potentieel medicijn waardoor het belangrijke eigenschappen van medicijnen kan voorspellen. Zoals of het medicijn werkzaam is, of er bijwerkingen zijn, in welk weefsel het medicijn zich het meeste bevind. JA, dacht ik. Dit is fantastisch! Ik wil zo snel mogelijk AI onder de knie krijgen!\nNu, een aantal jaren verder, heb ik veel geleerd. Van programmeren in Python tot het maken van neurale netwerken (een vorm van AI) en ik ben daar nog steeds iedere dag met passie mee bezig. Ook maak ik eigen projecten, maar hoe de reis verder zal gaan is nog onzeker. Mede daarom wil ik jullie graag mee nemen op deze reis. Daarnaast is het uitleggen van de technieken en termen die je zelf geleerd hebt de ultieme manier om jezelf te toetsen en dus vergt het dat je het onderwerp tot in de puntjes begrijpt. Als laatste, en misschien ook het belangrijkste, hoop ik jullie lezers te helpen bij het begrijpen van de soms lastige concepten die bij AI horen.\nDe droom om medicijnen te ontwikkelen met AI is er nog steeds, maar mijn eerste doel is een van de beste AI beoefenaars van Nederland te worden. Tot zo ver de eerste blog post en tot de volgende keer!\nMees"
  },
  {
    "objectID": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html",
    "href": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html",
    "title": "Een Flutter App - Deel 4 - De Integration Test",
    "section": "",
    "text": "Intro\nGoedemiddag! In de vorige post1 heb ik Github Actions opgezet om de unit, widget en integration tests uit te voeren. Deze actions draaien bij iedere code push, maar er worden nog geen tests uitgevoerd want we hebben nog geen tests! Daarom begin ik vandaag met de integration test.\nIn Flutter heb je drie soorten tests: integration, widget en unit tests. Laten we eerst kijken naar de integration tests. Dit zijn tests om de gehele app te testen. Deze test repliceert het gedrag van een gebruiker en is wat mij betreft daarom ook de belangrijkste soort test. Deze tests moeten altijd werken om te garanderen dat je app hetzelfde functioneert. Ten tweede, widget test: dit zijn tests (zoals de naam al doet vermoeden) om widgets, onderdelen van de User Interface (UI) te testen. En als laatste unit tests. Deze tests zijn handig om de werkzaamheid van losse functies of classes te testen. En deze tests zouden zo simpel moeten zijn dat ze zelfs op de pc van je oma kunnen draaien (ben de bron van deze quote kwijt). Maar waarom testen wij eigenlijk?\nPS: Hier is de Github repository\n\n\nIntegration Test\nWat wil ik eigenlijk testen met de integration test? Om dat te weten ga ik terug naar het oorspronkelijke idee2. Dus de app hoort een lijst van “practices” weer te geven met één actieve practice per dag. Deze actieve practice is gemarkeerd door een andere kleurencombinatie (zie schets hieronder).\n\nIn bovenstaande (hele ruwe) schets heb ik de belangrijke punten omcirkeld. Omdat de practices hardcoded in de app staan kan ik ervan uitgaan dat deze practices op volgorde staan. Daardoor kan je een test schrijven die de volgorde gebruikt: de eerste practice staat altijd in de lijst wanneer je de app start en ook moet je wanneer je naar beneden scrollt de laatste practice kunnen zien. Als laatste moet één practice van de lijst actief staan. Wanneer ik deze drie tests heb gemaakt (voor de MVP), wordt bij nieuwe code geverifieerd of de app nog werkt waardoor we zonder angst code kunnen aanpassen. Met dit plan kan ik beginnen om de tests te schrijven.\n\n\nIntegration Tests met Flutter\nAls eerste, om integration tests in Flutter te schrijven, heb je de integration_test3 en de flutter_test4 packages nodig. Vervolgens kan je de tests gaan schrijven (complete test code staat hieronder met extra commentaar).\nimport 'package:daily_practices_app/app/app.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('end-to-end test', () {\n    testWidgets('all practices are in the list and one is active',\n        (tester) async {\n      await tester.pumpWidget(\n        const DailyPracticeApp(),\n      );\n\n      // Wait till app is loaded\n      await Future.delayed(const Duration(seconds: 3), () {});\n\n      // Verify that the list can be found\n      final listFinder = find.byType(Scrollable);\n      expect(listFinder, findsOneWidget);\n\n      // Verify that the first practice can be found\n      expect(find.text('Sleep eight hours'), findsOneWidget);\n\n      // Scroll to the bottom\n      await tester.fling(\n        listFinder,\n        const Offset(0, -500),\n        10000,\n      );\n      await tester.pumpAndSettle();\n\n      // Verify that the last practice can be found\n      expect(find.text('Deep breathing'), findsOneWidget);\n\n      // Scroll back to the top\n      await tester.fling(\n        listFinder,\n        const Offset(0, 500),\n        10000,\n      );\n      await tester.pumpAndSettle();\n\n      final activeItemFinder = find.byKey(const ValueKey('ActivePractice'));\n\n      // Find the active practice\n      await tester.scrollUntilVisible(\n        activeItemFinder,\n        500.0,\n        scrollable: listFinder,\n      );\n\n      expect(activeItemFinder, findsOneWidget);\n    });\n  });\n}\nIk begin met IntegrationTestWidgetsFlutterBinding.ensureInitialized(); zodat de integration test ook kan worden uitgevoerd op een fysiek toestel. Daarna maak ik een nieuwe groep omdat je met groeperen van testen gemakkelijk een structuur aan je testen mee kunt geven. In deze groep wordt de test gemaakt met testWidgets(). In de callback van testWidgets wordt er een instantie van WidgetTester teruggeven (in onderstaande code opgeslagen als tester). Deze instantie is belangrijk omdat je hiermee onder andere kunt scrollen in je app!\nVervolgens zorg je er met pumpWidget() voor dat de gegeven widget wordt gerenderd (ofwel weergegeven). Daarna wacht ik kort zodat ik zeker weet dat het laden van de app voltooid is. Dan ga ik met Finders op zoek naar de scrollbare lijst en de eerste, laatste en actieve practice. Hierbij gebruik ik de fling() en scrollUntilVisible() methodes van WidgetTester om te scrollen. Als laatste gebruik ik expect() om te verifiëren of de Finders de practices daadwerkelijk gevonden hebben.\nOm de test na het maken ervan lokaal uit te voeren gebruik je deze command (integration_test is de mapnaam waar ik de integration_test heb opgeslagen)\n\nflutter test integration_test\n\nDeze test zal eerst falen, maar dat is goed! Volgens de Test Driven Development (TDD) principe mag je dan namelijk beginnen met het schrijven van de “echte code”. Maar dat is voor de volgende keer.\nAju :)!\nPS: Meer informatie over integration test in de Flutter documentatie5 6.\n\n\n\n\n\nFootnotes\n\n\nhttps://cabbagemees.nl/flutter/android/devops/ci/github%20actions/2022/09/27/Flutter-app-deel-3-CI-nog-geen-CD.html↩︎\nhttps://cabbagemees.nl/flutter/android/devops/2022/06/27/Flutter-app-deel-1-voorbereiding.html↩︎\nhttps://github.com/flutter/flutter/tree/main/packages/integration_test#integration_test↩︎\nhttps://api.flutter.dev/flutter/flutter_test/flutter_test-library.html↩︎\nhttps://docs.flutter.dev/cookbook/testing/widget/scrolling↩︎\nhttps://docs.flutter.dev/cookbook/testing/integration/introduction↩︎"
  },
  {
    "objectID": "posts/2022-07-13-Tussenproject-Tour-De-France-Voorspellen/index.html",
    "href": "posts/2022-07-13-Tussenproject-Tour-De-France-Voorspellen/index.html",
    "title": "Tussenproject - Tour de France Voorpspellen met Machine Learning",
    "section": "",
    "text": "Het jaarlijkse wielerspektakel de Tour de France staat weer voor de deur! Dat betekent ook dat ik renners mag gaan kiezen voor de eveneens jaarlijks terugkerende Wielerpoule (in het kort, je kiest een aantal wielrenners die mee gaan doen met de Tour en op basis van hun uitslag haal je punten). Nu heb ik de laatste jaren het wielrennen niet tot nauwelijks gevolgd waardoor ik geen idee heb welke renners er in vorm zijn. Daarom heb ik weer besloten om mijn programmeer en machine learning (ML) vaardigheden te gebruiken. Hiermee hoop ik het beste team samen te stellen. Als eerste hebben we data nodig om de beste renners te kunnen voorspellen en gelukkig is er een mooie website waar wij die data vanaf kunnen halen!\n\nData van een website halen\nOm met Python data van een website te halen heb je verschillende Python packages ter beschikking. Een van deze packages heb ik al vaker gebruikt en voor dit project ga ik dat weer gebruiken, BeautifulSoup (BS). Met BS kan je makkelijk navigeren door de HTML (opmaak) van een website en daarvandaan dan ook tekst ophalen. Maar dan moet je wel een website kunnen opvragen met coderen! Gelukkig kan dit ook met Python, namelijk met de requests package. In onderstaande code zie je een voorbeeld van hoe je een website in een BS object laad (zie hieronder).\n\n# Example: How to open a page using requests and BeautifulSoup\n\nrace_url = r\"https://www.procyclingstats.com/race/tour-de-france/2022/stage-4\"\n\n# Perform a get request on the url\nreq = requests.get(race_url)\n\n# Make a BeautifulSoup object from the requests's text\nsoup = BeautifulSoup(req.text, \"lxml\")\n\n# Get the title of the page\nprint(soup.find('title').string)\n\nFeatureNotFound: Couldn't find a tree builder with the features you requested: lxml. Do you need to install a parser library?\n\n\nVervolgens kan je ingebouwde methodes van het BS object gebruiken om door de HTML te zoeken. Zelf kijk ik eerst in de internet browser naar de elementen van de website waarvan ik de data wil. Afhankelijk van de browser die je gebruikt kan je elementen inspecteren. Ik let daarbij op het het HTML type (div, table, etc) en of het een class of id heeft. Met deze informatie kan je dan een specifiek element zoeken, zoals de top-20 van een uitslag (zie hieronder).\n\n# Example: Getting the top-20 results of a race\n\nrace_url = r\"https://www.procyclingstats.com/race/tour-de-france/2022/stage-4\"\n\n# Perform a get request on the url\nreq = requests.get(race_url)\n\n# Make a BeautifulSoup object from the requests's text\nsoup = BeautifulSoup(req.text, \"lxml\")\n\n# I used the browser to find the element we are interested in\nresult_list = soup.find(\"table\", class_=\"results basic moblist10\").find(\"tbody\")\n\n# Each result is in a table row (tr)\nresults = result_list.find_all(\"tr\")\n\nrace_top_20 = {}\n\nfor i in range(20):\n    result = results[i]\n    \n    # Again, use your browser to find the element you are interested in\n    rider = result.find_all(\"a\")[0].text\n    \n    race_top_20[i + 1] = rider \n    \npprint.pprint(race_top_20)\n\nFeatureNotFound: Couldn't find a tree builder with the features you requested: lxml. Do you need to install a parser library?\n\n\n\n\nDe opgehaalde data\nIn totaal had ik deze data opgehaald: * Van de Tour de France van 2000 - 2021 alle renners die mee deden * Via al die renners, voor ieder jaar, de races en eindklassering URLs * Voor alle renners de geboortedatum, de teams en de PCS score (de laatste twee voor ieder jaar) * Voor iedere race de datum, top-20 en de gemiddelde PCS score van de top-20\nNadat al deze data is verzameld kunnen we deze data gebruiken om de features te gaan maken waarmee je een ML model kunt trainen.\n\n\nFeatures maken\nEen feature is een deel van de totale informatie waarmee je een voorspelling kunt maken. Bijvoorbeeld, wanneer je iemands gewicht wilt voorspellen aan de hand van iemands lengte, dan is lengte je feature (zie grafiek hieronder). Hoewel het verband tussen gewicht en lengte niet 1 op 1 is zijn over het algemeen lange mensen zwaarder dan kleine mensen. Een andere feature die je dan zou kunnen toevoegen om je voorspelling te verbeteren is bijvoorbeeld het aantal uren sporten per week. Samen met de lengte zal dit betere voorspellingen geven omdat (vaak) wanneer je meer sport je geen uitschieter hebt in gewicht (een nogal grove aanname). Zoals je misschien merkt kan je vele features bedenken en daarom heb je zeker een mate van creativiteit nodig!\n\n\n\n                                                \n\n\n\ndata van: https://www.tno.nl/groei\n\nTwee jaar geleden (v1) had ik ook een ML model gemaakt maar dit keer wilde ik nieuwe features gebruiken. In V1 had ik het idee om de races op te delen in types (vlak, heuvelachtig met vlakke finish, heuvelachtig met finish bergop, gebergte met vlakke finish en gebergte met finish bergop; Voor de races waar dit niet voor bekend was had ik zelfs een model getraind om dat te voorspellen). Vervolgens had ik voor iedere types de plekken 1 t/m 4, 5 t/m 8 en 9 t/m 12 ingedeeld (zie Tabel hieronder). Voor iedere renner telde ik dan in het voorgaande jaar hoe vaak iemand deze uitslag in deze type had (zie voorbeeld van Chris Froome hieronder). Hoewel ik best tevreden was met deze features, namen ze niet mee hoe sterk het deelnemersveld was. Wanneer je veel wint maar je tegenstand niet heel sterk is, is deze overwinning minder relevant (weer een grove aanname) in de Tour, want in de Tour is het deelnemersveld vaak erg sterk. Daarom heb ik voor deze Tour de France nieuwe features bedacht.\n\n\n\nFeatures\nChris Froome\n\n\n\n\nPCS\n1377\n\n\nTeam PCS\n4172\n\n\nAge\n29\n\n\nflat1-4\n1.0\n\n\nflat5-8\n0.0\n\n\nflat9-12\n2.0\n\n\nhills(flat)1-4\n1.0\n\n\nhills(flat)5-8\n0.0\n\n\nhills(flat)9-12\n1.0\n\n\nhills(uphill)1-4\n2.0\n\n\nhills(uphill)5-8\n1.0\n\n\nhills(uphill)9-12\n1.0\n\n\nmountains(flat)1-4\n1.0\n\n\nmountains(flat)5-8\n0.0\n\n\nmountains(flat)9-12\n1.0\n\n\nmountains(uphill)1-4\n4.0\n\n\nmountains(uphill)5-8\n5.0\n\n\nmountains(uphill)9-12\n1.0\n\n\ngc1-4\n3.0\n\n\ngc5-8\n1.0\n\n\ngc9-12\n1.0\n\n\n\nVoor deze Tour nemen we bij iedere rit dus de sterkte van het deelnemersveld mee. Dat doen we door de gemiddelde PCS score van de top-20 uit te rekenen. Vervolgens verdelen we de ritten in 5 kwantielen (zeer weinig competitief, weinig competitief, competitief, erg competitief en zeer erg competitief). En daarbij had ik dan dit keer de resultaten als volgt verdeeld: 1 t/m 5, 6 t/m 10, 11 t/m 15 en 16 t/m 20 (zie tabel met voorbeeld van Wout van Aert hieronder).\n\n\n\nFeatures\nWout van Aert\n\n\n\n\nPCS\n2820\n\n\nTeam PCS\n9724\n\n\nPCS ratio\n0.29\n\n\nAge\n27\n\n\ntop_5s_category_0\n0\n\n\ntop_10s_category_0\n0\n\n\ntop_15s_category_0\n0\n\n\ntop_20s_category_0\n0\n\n\ntop_5s_category_1\n0\n\n\ntop_10s_category_1\n0.0\n\n\ntop_15s_category_1\n0\n\n\ntop_20s_category_1\n0\n\n\ntop_5s_category_2\n2\n\n\ntop_10s_category_2\n0\n\n\ntop_15s_category_2\n0\n\n\ntop_20s_category_2\n0\n\n\ntop_5s_category_3\n1\n\n\ntop_10s_category_3\n1\n\n\ntop_15s_category_3\n0\n\n\ntop_20s_category_3\n0\n\n\ntop_5s_category_4\n11\n\n\ntop_10s_category_4\n2\n\n\ntop_15s_category_4\n2\n\n\ntop_20s_category_4\n0\n\n\ntop_5s_category_gc\n1.0\n\n\ntop_10s_category_gc\n0.0\n\n\ntop_15s_category_gc\n0\n\n\ntop_20s_category_gc\n0\n\n\n\nDaarnaast had ik nog een aantal renner specifieke features: leeftijd, PCS score, PCS punten van het team en PCS ratio (eigen PCS / team PCS). Nu hebben we alle features waarop we een ML model kunnen trainen!\n\n\nHet trainen van een model\nVoor data, zoals in dit project, in een tabel structuur is het meest gebruikte en vaak ook beste model een vorm van een gradient boosted tree. In het kort is een tree vaak verdeeld in een aantal ja/nee vragen. Een voorbeeld van een simpele tree is een decision tree (voorbeeld hieronder). Het idee van deze tree is in de loop van de tijd al meer uitgebreid, van random forests naar dus gradient boosted trees. Dit zijn (simpel en kort door de bocht) een verzameling van meerdere trees die na het trainen heel goed zijn om een voorspelling te maken. Een van mijn favoriete tree algoritmes is XGBoost en deze gaan we dan ook gebruiken!\n\nEen XGBoost model is redelijk makkelijk te trainen door (jawel alweer!) een Python package: XGBoost. Alhoewel, je hebt dan nog heel veel instellingen die kunt optimaliseren. Gelukkig heb je daar ook een goede bron voor, namelijk Gridsearch van Sklearn (alweer een package!). Wanneer je Gridsearch en XGBoost combineert kan je meerdere instellingen vergelijken en dan krijg je als resultaat de getrainde modellen (met de verschillende parameters). Je kunt dan zelfs het beste model met de beste instellingen opvragen! Ideaal en het voelt als magie!\n\n\nDe resultaten\nDe resultaten van het model zien er op het eerste gezicht niet raar uit (zie hieronder). De volgens Wielerpoule duurste renners zitten qua voorspelling bovenin. Met voor mij als opvallendste naam Vlasov (voor mij geen bekende naam maar de laatste tijd volg ik het wielrennen nauwelijks). Om mijn team samen te stellen heb ik de voorspelde punten gedeeld door de kosten. En daar heb ik, naast de top 4, mijn team mee opgevuld. Eens zien of we mee gaan spelen voor de prijzen!\n\n\n\n\nrider_name\nprediction\nprice\nscore_price_ratio\n\n\n\n\n\nVAN DER POEL Mathieu\n84.196594\n200\n0.420983\n\n\n\nVLASOV Aleksandr\n75.061699\n150\n0.500411\n\n\n\nPOGACAR Tadej\n70.501328\n200\n0.352507\n\n\n\nROGLIC Primož\n67.192093\n200\n0.335960\n\n\n\nVAN AERT Wout\n66.121864\n200\n0.330609\n\n\n\nMARTINEZ Daniel Felipe\n58.990757\n100\n0.589908\n\n\n\nVINGEGAARD Jonas\n57.898109\n150\n0.385987\n\n\n\nJAKOBSEN Fabio\n55.955868\n150\n0.373039\n\n\n\nKUNG Stefan\n55.773567\n100\n0.557736\n\n\n\nKRISTOFF Alexander\n54.939995\n100\n0.549400\n\n\n\nCOSNEFROY Benoit\n54.132721\n100\n0.541327\n\n\n\nPEDERSEN Mads\n50.576691\n100\n0.505767\n\n\n\nMOHORIC Matej\n50.398064\n100\n0.503981\n\n\n\nVAN BAARLE Dylan\n49.590599\n100\n0.495906\n\n\n\nHOFSTETTER Hugo\n49.079250\n100\n0.490793\n\n\n\nEWAN Caleb\n46.512360\n100\n0.465124\n\n\n\nLAPORTE Christophe\n44.920681\n100\n0.449207\n\n\n\nTEUNS Dylan\n44.595673\n100\n0.445957\n\n\n\nMCNULTY Brandon\n44.574734\n100\n0.445747\n\n\n\nPHILIPSEN Jasper\n44.041866\n100\n0.440419\n\n\n\nTot de volgende keer en veel plezier met het volgen van de Tour de France!\nMees\nP.S: De uiteindelijke dataset samen met de code voor het trainen van het ML model kan je vinden in deze Github repo.\nP.S 2: Tot dusver werkt het model (na ongeveer 1 week) redelijk. Helaas valt Mathieu van der Poel tegen (en die was het duurste)."
  },
  {
    "objectID": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html",
    "href": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html",
    "title": "Kwaadaardige moedervlekken herkennen met artificiële intelligentie",
    "section": "",
    "text": "Hoi hoi,\nVandaag wil ik een voorbeeld delen van Artificiële Intelligentie (AI) in de biologie. Maar voordat ik begin, een kleine waarschuwing. In deze post komen mogelijk onbekende en moeilijke termen voor. Wanneer ik ze allemaal in deze post uit ga leggen wordt de post ietwat lang. Daarom heb ik soms een korte uitleg gegeven ,maar op andere momenten niet ,want het idee is om deze termen uitvoerig te bespreken in de volgende posts. Dat gezegd hebbende, deze post gaat over mijn eerste project dat ik gemaakt heb, namelijk een model (eigenlijk een soort van computerprogramma) dat kan voorspellen of een moedervlek goed- of kwaadaardig is 1. Hiermee was ik begonnen ,omdat de (gratis!) online cursus van Fastai 2 aanbeveelt om zo snel mogelijk te experimenteren. Zo kan je spelenderwijs leren en later, mocht je het interessant vinden, dieper in de theorie duiken.\nOm het nog makkelijker te maken en sneller te kunnen beginnen met experimenteren heeft Fastai een eigen Python library (een term dat gebruikt wordt als: een uitbreiding van de programmeertaal Python). Met deze library, kun je met relatief weinig programmeerkennis een model trainen dat een voorspelling kan maken van, ja van wat niet eigenlijk. Dit kan zolang je maar genoeg voorbeelden (je data) hebt. Gelukkig hoef je niet altijd zelf je data te verzamelen, maar zijn er mensen die data gratis met de wereld delen. Tschandl et al.3 hebben plaatjes van moedervlekken bij elkaar gezocht en gelabeld (een label is de waarde die de data, in dit geval een foto, heeft). Specialisten op het gebied van moedervlekken hebben iedere foto beoordeeld als goed- of kwaadaardige moedervlek. Deze stap is erg belangrijk ,want zonder gelabelde data kun je eigenlijk geen AI model maken dat een nuttige voorspelling kan doen (met uitzondering van technieken die ongelabelde data gebruiken, maar dat is voor een volgende keer). En vaak geldt: des te meer data ,des te beter.\nNu we onze data hebben ,kunnen we bijna beginnen om een AI model te trainen. We hebben namelijk ook data nodig om ons model te evalueren. Hiervoor gebruik je data die niet is gebruikt tijdens het trainen. In de praktijk splits je daarom je data vaak in twee groepen. Een groep die je gebruikt om je model te trainen en een groep om te evalueren. Door deze splitsing evalueer je het getrainde model met data dat je model nog niet gezien heeft tijdens de training. Dat is erg belangrijk, want uiteindelijk wordt je model ook op deze manier gebruikt! Een foto die een gebruiker instuurt heeft het model nog nooit gezien en op deze foto’s wil je een accurate voorspelling doen.\nOk, nu kunnen we dan echt beginnen met het trainen van het model. Voor foto’s en plaatjes wordt (vaak) een speciale vorm model gebruikt, namelijk een convolutioneel neuraal netwerk (CNN; nog een term die ik later verder ga uitleggen, voor nu kan je een convolutie zien als een speciale rekensom). Zo ’n CNN gaan wij nu ook gebruiken (en de Fastai library maakt het ons erg gemakkelijk om dit te doen, maar de details bespreek ik weer later).\nTabel 1: Het trainen van een model. Epochs staat voor hoeveel keer je door je data heen gaat om je model te trainen. De train_loss is de loss die het model heeft op de trainingsdata en de valid_loss van je evaluatie data (hoe de loss wordt berekend ga ik later bespreken, de loss is berekend door het verschil tussen de voorspelde waarde door het model en de echte (gelabelde) waarde in een formule te stoppen). Als laatste bevat de tabel de tijd die 1 epoch duurt in minuten.\n\nIn onderstaande tabel zie je dat we (na maar een paar minuten trainen) een accuuraatheid van maarliefst 95% hebben (Tabel 1; De error rate is lager dan 0.05, wat betekent dat de accuraatheid groter is dan (1 - 0.05) * 100%). Dat is de kracht van transfer learning en trainen op een grafische kaart (GPU). Een wezenlijk probleem is echter dat de accuraatheid verbonden is aan of je model een soortgelijke moedervlek heeft gezien tijdens de training. Hoewel we dat probleem zo goed mogelijk proberen op te lossen door je data te splitsen, is het nog steeds een probleem wanneer een moedervlek er compleet anders uit ziet, dan de moedervlekken waarop je het model hebt getraind. Dat is een reden waarom deze modellen in de praktijk nog geen specialisten vervangen en waarom je dus met een gek uitziende moedervlek altijd naar een specialist moet gaan. Maar deze modellen kunnen wel als hulpmiddel dienen voor deze specialisten! Dit voorbeeld laat dus de kracht, maar zeker ook een grote uitdaging van AI zien.\nEr zijn veel voorbeelden waar soortgelijke technieken worden gebruikt (zie tabel 2). De code van dit project kan je vinden op Github en je kunt het getrainde model ook testen met een foto van een eigen moedervlek of eentje van het internet (moedervlek herkenner).\nTabel 2: Voorbeelden van andere projecten waarin biologische problemen worden opgelost met afbeeldingen.\n\n\n\n\n\n\n  \n    \n      \n      Soort Scan\n      Functie\n      Artikel\n    \n  \n  \n    \n      0\n      MRI\n      Hersen Tumoren\n      Ali Işın, Cem Direkoğlu, Melike Şah, Review of MRI-based Brain Tumor Image Segmentation Using Deep Learning Methods, Procedia Computer Science, Volume 102,2016,Pages 317-324,ISSN 1877-0509,https://doi.org/10.1016/j.procs.2016.09.407.\n    \n    \n      1\n      H&E gekleurde cellen\n      Infiltrerende lymfocyten in tumoren\n      Spatial Organization and Molecular Correlation of Tumor-Infiltrating Lymphocytes Using Deep Learning on Pathology Images, Cell Reports, Volume 23, Issue 1, Pages 181-193.e7, ISSN 2211-1247, https://doi.org/10.1016/j.celrep.2018.03.086.\n    \n    \n      2\n      X-ray\n      Borstkas aandoeningen\n      Han Liu, Lei Wang, Yandong Nan, Faguang Jin, Qi Wang, Jiantao Pu, SDFN: Segmentation-based deep fusion network for thoracic disease classification in chest X-ray images, Computerized Medical Imaging and Graphics, Volume 75, Pages 66-73, ISSN 0895-6111, https://doi.org/10.1016/j.compmedimag.2019.05.005.\n    \n  \n\n\n\n\nWe zijn weer aan het einde gekomen en ik kan me goed voorstellen dat het duizelt van de moeilijke termen. Ik ga proberen om die termen in toekomstige berichten zo duidelijk mogelijk uit te leggen. Mochten er vragen of opmerkingen zijn, dan kunnen jullie die hieronder plaatsen! Bedankt voor het lezen en tot de volgende keer! (Smeer je goed in tegen de zon!!).\n\n\n\n\nFootnotes\n\n\nDit soort modellen zijn geen vervanging van een specialist. Wanneer je een rare (moeder)vlek hebt, raadpleeg altijd een dokter.↩︎\nFastai website↩︎\nTschandl, Philipp, 2018, The HAM10000 dataset, a large collection of multi-source dermatoscopic images of common pigmented skin lesions, https://doi.org/10.7910/DVN/DBW86T, Harvard Dataverse, V3↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CabbageMees",
    "section": "",
    "text": "Een Flutter App - Deel 5 - De simpelste implementatie van de App\n\n\nEindelijk starten met het maken van de app!\n\n\n\n\nFlutter\n\n\nAndroid\n\n\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nSide Project - Combining FastAPI and nbdev\n\n\nEasily write a documented web API\n\n\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nNov 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nEen Flutter App - Deel 4 - De Integration Test\n\n\nHet schrijven van een Integration Test in Flutter\n\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\nCI\n\n\nGithub Actions\n\n\nintegration test\n\n\n\n\n\n\n\n\n\n\n\nOct 16, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nEen Flutter App - Deel 3 - CI Nog Geen CD\n\n\nHet opzetten van Continuous Integration pipelines met Github Actions\n\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\nCI\n\n\nGithub Actions\n\n\n\n\n\n\n\n\n\n\n\nSep 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nEen Flutter App - Deel 2 - Voorbereiden App Structuur\n\n\nHoe gaat de code-structuur van de app er uit zien?\n\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\n\n\n\n\n\n\n\n\n\nJul 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nTussenproject - Tour de France Voorpspellen met Machine Learning\n\n\nBest presterende renners van de Tour de France voorspellen\n\n\n\n\nPython\n\n\nTussenproject\n\n\nAI\n\n\nML\n\n\n\n\n\n\n\n\n\n\n\nJul 13, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nEen Flutter App - Deel 1 - Voorbereiding\n\n\nEen Android applicatie maken met Flutter\n\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\n\n\n\n\n\n\n\n\n\nJun 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nEen Nieuwe Stap\n\n\nEen nieuwe stap in het blog avontuur\n\n\n\n\nDe reis\n\n\n\n\n\n\n\n\n\n\n\nJun 7, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n  \n\n\n\n\nKwaadaardige moedervlekken herkennen met artificiële intelligentie\n\n\nEen voorbeeld van een AI project dat een biologisch probleem kan oplossen\n\n\n\n\nProjecten\n\n\nCNN\n\n\nBiologie\n\n\n\n\n\n\n\n\n\n\n\nJun 19, 2021\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelkom op CabbageMees!\n\n\nWaarom begin ik met bloggen\n\n\n\n\nDe reis\n\n\nIntroductie\n\n\n\n\n\n\n\n\n\n\n\nMay 26, 2021\n\n\nMees Molenaar\n\n\n\n\n\n\nNo matching items"
  }
]