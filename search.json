[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Over Mij",
    "section": "",
    "text": "Hallo,\nLeuk dat je kijkt op deze blog van een rare vogel (een Koolmees bijvoorbeeld). In dit blog neem ik je mee in de wonderlijke wereld van programmeren en Artificiele Intelligentie (AI). De laatste tijd ligt de focus meer op programmeren dan AI, wat ook te zien is aan de laatste posts over mobiele apps met Flutter en nu ook Rust.\nHet doel blijft om uiteindelijk de Life Science & Technology te combineren met programmeren en AI. Je ziet me de laatste ontwikkelingen (zoals ChatGPT en DALLE, hiermee maak ik de plaatjes van de blogposts) wat voor een vette dingen je met AI kunt doen. Ik denk dat er in dit gebied nog vele mooie vernieuwingen gaan komen!\n\nWat doe ik nu (13MAY24)\nWerk: Machine Learning Engineer bij Xomnia\n\nProject\n\nRecepten App\nMinecraft Discord Bot\n\nThinking about creating a Vector DB for the bot so I can deploy it on a Raspberry Pi\n\nRust CLI Repo Harvest\n\n\n\nBoeken\n\nFrank Herbert - Dune"
  },
  {
    "objectID": "posts/2022-09-27-Flutter-app-deel-3-CI-nog-geen-CD/index.html",
    "href": "posts/2022-09-27-Flutter-app-deel-3-CI-nog-geen-CD/index.html",
    "title": "Een Flutter App - Deel 3 - CI Nog Geen CD",
    "section": "",
    "text": "Intro\nHallootjes,\nwelkom bij de volgende stap in het proces om een Flutter app te maken. In de vorige post heb ik de app-structuur bepaald, maar voordat wij daaraan beginnen gaan we eerst een Continuous Integration (CI) pipeline opzetten. Deze pipeline zorgt ervoor dat wanneer er nieuwe code wordt gepushed er automatisch wordt gecontroleerd of de bestaande code en app nog naar behoren werken. Dit doe je door tests te schrijven die vervolgens worden uitgevoerd door je pipeline.\nPS: Hier is de Github repository\nIn Flutter heb je drie soorten tests: integration, widget en unit tests. Laten we eerst kijken naar de integration tests. Dit zijn tests om de gehele app te testen. Deze test repliceert het gedrag van een gebruiker en is wat mij betreft daarom ook de belangrijkste soort test. Deze tests moeten altijd werken om te garanderen dat je app hetzelfde functioneert. Ten tweede, widget test: dit zijn tests (zoals de naam al doet vermoeden) om widgets, onderdelen van de User Interface (UI) te testen. En als laatste unit tests. Deze tests zijn handig om de werkzaamheid van losse functies of classes te testen. En deze tests zouden zo simpel moeten zijn dat ze zelfs op de pc van je oma kunnen draaien (ben de bron van deze quote kwijt). Maar waarom testen wij eigenlijk?\nEr zijn een legio voordelen aan het automatisch testen van code, zoals het besparen van kosten (omdat je (minder) manueel hoeft te testen), sneller developen en deployen en een hogere code qualiteit. Lees voor nog meer voordelen en adviezen over automatisch testen eens The DevOps Handbook. Maar de belangrijkste van alles is het korter maken van de feedback loop. Als developer is er namelijk niets frustrerender dan dat je code hebt gemaakt waarna je maanden later hoort dat er iets niet werkte. Het zou veel beter zijn om direct te weten dat er iets niet meer werkt zodat je na jou aanpassing/toevoeging het probleem direct kan oplossen en daar dan ook van te leren. In tegenstelling tot lang wachten want dan weet je niet eens meer waarom je dat stukje code hebt geschreven laat staan hoe je het kunt oplossen.\n\n\nGithub Actions\nVoor deze CI pipelines ga ik Github Actions gebruiken. Het voordeel hiervan is dat de code, het project board en de pipelines allemaal in één omgeving staan (namelijk Github). Daarnaast zijn Github Actions voor Publieke repositories gratis (voor Private repositories heb je een aantal gratis minuten per maand en daarna betaal je voor de minuten die je extra gebruikt)! Github Actions heeft zogeheten Runners (een virtuele machine die je pipeline uitvoert) met verschillende Operation Systems (OS). Omdat je geen Android of IPhone emulator op een Linux machine kunt draaien, gebruiken we daarvoor macOS runners (let op! in private repos kunnen de kosten van deze runners snel oplopen! Ze zijn namelijk 10x zo duur). Deze emulators zijn nodig om de integratie tests uit te voeren. Maar laten we eerst de eenvoudige tests bespreken: de unit en widget tests.\n\n\nUnit en Widget Tests\nVoor de Unit en Widget tests heb je weinig nodig. Eigenlijk alleen een computer met Flutter geïnstalleerd en dan kan je gemakkelijk de volgende command uitvoeren:\n\nflutter test\n\nDeze stappen uit voeren met een Github Action zijn ook gemakkelijk! Als eerste moet je Flutter installeren. Op de Github Marketplace heeft een gebruiker een Action gedeeld waarmee je de gewenste Flutter versie kan installeren. Vervolgens installeer je de packages en dan test je (voorbeeld hieronder). Deze YAML bestander sla je op onder de folders .github/workflows en deze workflow zal af gaan iedere keer dat er code naar main wordt gepushed.\nname: Flutter Unit And Widget Tests\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      - name: Analyze the code\n        run: flutter analyze\n\n      - name: Run unit tests with coverage\n        run: flutter test --coverage\nVoorbeeld is gebaseerd op: Run Flutter tests using GitHub Actions and Codecov\n\n\nWeb Integration Tests\nDe volgende makkelijk op te zetten tests zijn web integratie testen. Deze draaien namelijk met een Chrome Driver die je ook op Linux machines kunt installeren. Hieronder is een voorbeeld voor een Github Workflow dat web integration tests uitvoert. Maar voordat je deze kunt uitvoeren, heb je een klein Dart bestandje nodig die de integrationDriver start (zie hieronder) (klik hier voor extra informatie). Vervolgens kan je met de command:\n\nflutter drive\n\nde web integration test starten. Het nadeel is wel dat je het bestand dat je wilt testen moet specificeren. Dat resulteert in één groot integration test bestand. Zelf vind ik het fijner om tests te verdelen in verschillende bestanden, maar daar is helaas voor deze web integration tests nog geen oplossing voor.\nname: Flutter Web Integration Tests\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      - name: Start Chromedriver\n        run: chromedriver --port=4444 &\n\n      - name: Run Web integration test\n        run: flutter drive --driver=test_driver/integration_test.dart --target=integration_test/integration_test.dart -d web-server\nVoorbeeld is gebaseerd op: Run Flutter Integration Tests in GitHub Actions\n\n\nIPhone Integration Tests\nNu zijn we aangekomen bij de complexere integration tests (en ook bij de duurdere wanneer je een Private repo hebt). Deze tests worden namelijk uitgevoerd op een macOS runner. Ook zit er een klein stukje code in de Github Action dat ervoor zorgt dat je de juiste UDID krijgt van de IPhone Emulator. Met deze UDID kan je dan succesvol de integration testen uitvoeren (zie voorbeeld Action hieronder). In het geval van deze integration tests kun je de folder waar de tests zich bevinden aangeven i.p.v. een bestand zoals met de web integration tests. Hierdoor kan je de tests wel verdelen in verschillende bestanden.\nname: flutter iphone integration test\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  iphone_integration_test:\n    # NOTE: Running on macOS\n    runs-on: macOS-latest\n\n    # The device name is saved in an environment variable\n    # we use this environment variable to search for the device UDID\n    env:\n      device: 'iPhone 13 Simulator \\(16.0\\)'\n\n    steps:\n      # We list the simulators for debugging purposes\n      # when the device in the environment variable is not in this list\n      # we have to change it to one that is in the list\n      - name: List all simulators\n        run: xcrun xctrace list devices\n\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      # We first get the UDID of the device with an awk command\n      # Then we boot that device and use that device for the integration test with the -d flag\n      - name: Get UDID device, Start Simulator and Connect flutter\n        run: |\n          UDID=$(xcrun xctrace list devices | awk -F \" \" '/${{ env.device }}/ && length($5) &gt; 1 {print $5}' | tr -d '()')\n          echo $UDID\n          xcrun simctl boot \"${UDID:?No Simulator with this name found}\"\n          flutter test integration_test -d $UDID\nVoorbeeld is gebaseerd op: Run Flutter Driver tests on GitHub Actions\n\n\nAndroid Integration Tests\nOok de Android integration tests kan je enkel draaien op een macOS runner. Omdat Android Gradle gebruikt om je app te builden (zo heet dat) heb je Java versie 11 of hoger nodig. Wanneer je die actie hebt uitgevoerd installeer je wederom Flutter. Als laatste gebruiken we een actie van ReactiveCircus om een Android Emulator te starten. Aan deze actie moeten de minimum api-leven en het uit te voeren script worden mee gegeven.In dit geval is het script een losse command.\nname: flutter android integration test\n\n# Perform action when code is pushed to the main branch\non:\n  push:\n    branches: [main]\n\njobs:\n  android_integration_test:\n    runs-on: macOS-latest\n\n    steps:\n      # First checkout the new code\n      - name: Checkout the code\n        uses: actions/checkout@v3\n\n      # We need atleast Java 11 or Higher to build your app with this version of Gradle\n      # So we use this Marketplace Action to install it\n      - name: Setup Java JDK\n        uses: actions/setup-java@v3.5.0\n        with:\n          distribution: \"zulu\"\n          java-version: \"11.x\"\n\n      # Use a handy action from the Github marketplace to install flutter\n      - name: Install and set Flutter version\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: \"3.3.10\"\n          channel: \"stable\"\n\n      - name: Show Flutter version\n        run: flutter --version\n\n      - name: Get Flutter packages\n        run: flutter pub get\n\n      # Use a Github Action from the Marketplace to start an Android Emulator with api-level 23\n      - name: Start Emulator And Start Tests\n        uses: reactivecircus/android-emulator-runner@v2\n        with:\n          api-level: 23\n          script: flutter test integration_test\nNu de verschillende pipelines zijn opgezet push ik dit naar Github en zullen deze de tests draaien wanneer ik nieuwe code naar Github push. Daarvoor zijn natuurlijk nog wel de afzonderlijke unit, widget en integratie tests nodig! Dus deze zullen snel volgen.\nDit was het voor nu, tot de volgende keer en geniet van de herfst :).\nMees"
  },
  {
    "objectID": "posts/2021-05-26-Eerste-blog-post/index.html",
    "href": "posts/2021-05-26-Eerste-blog-post/index.html",
    "title": "Welkom op CabbageMees!",
    "section": "",
    "text": "Hoi,\nMijn naam is Mees en sommige zullen zeggen dat ik een rare vogel ben (een koolmees bijvoorbeeld). In 2020 heb ik mijn Life Science & Technology diploma van de Universiteit Leiden behaald. Nu wil ik deze kennis over de biologie verbinden met een andere passie van mij, namelijk programmeren en meer specifiek Artificiële Intelligentie (AI). Via deze blog wil ik jullie graag op de hoogte houden van mijn bezigheden.\nMaar eerst nog even terug naar waar het allemaal begon. Toen ik nog jonger en kleiner was dan nu, was het mijn droom om een middel te vinden tegen kanker. Dat was voor mij de reden om, na de middelbare school, Life Science & Technology te gaan studeren. Tijdens de studie kwam ik tot de conclusie dat het laboratorium niks voor mij was en dat ik op deze manier nooit een medicijn zou uitvinden. Dit was een enorme teleurstelling, maar gelukkig kwam ik er snel achter dat je op veel meer manieren bij kan dragen aan het ontwikkelen van medicijnen. Zo ben ik in aanraking gekomen met AI.\nDe eerste kennismaking was tijdens het vak computationele medicijn ontwikkeling (gegeven door prof. dr. ir. Fraaije). Tijdens deze colleges bespraken wij bijvoorbeeld Quantitative Structure-Activity Relationship (QSAR), een machinaal leren (een vorm van AI) techniek om te voorspellen wat voor eigenschappen een molecuul heeft (zoals elektronegativiteit). Dit sprak erg tot mijn verbeelding. En zo begon het fantaseren over een computer programma wat alles weet van het menselijk lichaam en van een potentieel medicijn waardoor het belangrijke eigenschappen van medicijnen kan voorspellen. Zoals of het medicijn werkzaam is, of er bijwerkingen zijn, in welk weefsel het medicijn zich het meeste bevind. JA, dacht ik. Dit is fantastisch! Ik wil zo snel mogelijk AI onder de knie krijgen!\nNu, een aantal jaren verder, heb ik veel geleerd. Van programmeren in Python tot het maken van neurale netwerken (een vorm van AI) en ik ben daar nog steeds iedere dag met passie mee bezig. Ook maak ik eigen projecten, maar hoe de reis verder zal gaan is nog onzeker. Mede daarom wil ik jullie graag mee nemen op deze reis. Daarnaast is het uitleggen van de technieken en termen die je zelf geleerd hebt de ultieme manier om jezelf te toetsen en dus vergt het dat je het onderwerp tot in de puntjes begrijpt. Als laatste, en misschien ook het belangrijkste, hoop ik jullie lezers te helpen bij het begrijpen van de soms lastige concepten die bij AI horen.\nDe droom om medicijnen te ontwikkelen met AI is er nog steeds, maar mijn eerste doel is een van de beste AI beoefenaars van Nederland te worden. Tot zo ver de eerste blog post en tot de volgende keer!\nMees"
  },
  {
    "objectID": "posts/2022-06-07-Een-nieuwe-stap/index.html",
    "href": "posts/2022-06-07-Een-nieuwe-stap/index.html",
    "title": "Een Nieuwe Stap",
    "section": "",
    "text": "Een Tijdje Geleden\nHet is alweer een tijdje geleden dat ik voor het laatste iets op de blog geschreven heb. Toen ik begon als Machine Learning (ML) Engineer was ik vooral daar mijn tijd aan kwijt, zodat ik mij zo goed mogelijk kon ontwikkelen en een mooi product kon maken. Ik denk dat ik mag zeggen dat beide zijn gelukt. Het gevolg daarvan is dat ik een volgende stap mag zetten naar een nieuwe werkgever waar ik ontzettend naar uit kijk! Voordat ik daar zou gaan beginnen hadden mijn vriendin en ik drie weken vakantie genomen, waarin we veel rust hebben gepakt. Ook heb ik kunnen nadenken over activiteiten naast werk, zoals deze blog. Hier had ik, toen ik begon, bepaalde ideeën over, maar deze zijn nu veranderd. In deze post wil ik dat toelichten en hopelijk lijkt het jullie interessant om met mij een nieuw avontuur te beleven.\n\n\nHet Nieuwe Idee\nTijdens de vakantie heb ik een nieuw idee bedacht om het voor mezelf makkelijker te maken om meer te gaan bloggen, namelijk op projectbasis. Zelf programmeer ik namelijk ook in projecten en ik denk dat dit zal helpen met het schrijven van een blogpost. Daarbij komt ook dat het proces van een nieuw project niet vaak beschreven wordt (althans ik heb dit naast standaard tutorials niet veel gevonden). Wellicht is het voor anderen ook waardevol om via deze weg meer te leren over het maken van een nieuw project.\n\n\nDe Planning\nVoor nu heb ik een voorlopige planning gemaakt maar deze staat zeker niet vast (Ik schrijf nu namelijk op de Note Air 2, en het zou super handig zijn wanneer handgeschreven notities automatisch worden omgezet naar een Jupyter Notebook. Aan dit project ben ik meteen begonnen wat de planning na 2 dagen al overhoop gooide :)). Maar toch probeer ik mij aan deze planning te houden:\n\n\nAutomatisch handgeschreven tekst naar Jupyter Notebook\nAndroid app maken (Minimum Viable Product: MVP)\n\nFunctioneel programmeren Python module schrijven (op basis van het boek Grocking Simplicity)\nAnki Add-on (MVP)\nRecepten Web-App (MVP)\n\nDaarna wordt het waarschijnlijk het verbeteren van de MVPs naar nieuwere versies. Maar zoals gezegd, bestaat er een kans op verschuivingen in de planning en tussenkomende projecten.\n\n\nProces\nOok wil ik zoveel mogelijk via DevOps (hierover later meer!) principes gaan werken om zo te laten zien hoe je in de praktijk (wat ik nu weet) zou kunnen werken. Zelf heb ik namelijk ondervonden dat dit nauwelijks wordt uitgelegd. Ik geloof dat werken met DevOps principes veel voordelen heeft maar dat ik mij hier nog veel in kan verbeteren. Daarom ga ik dat in eigen projecten toepassen en hoor ik ook graag wat jullie zouden doen!\nHopelijk geeft dit een duidelijk beeld en lijkt het jullie leuk om te volgen. Bedankt voor het lezen en hopelijk tot de volgende keer!\nFijne dag!\nMees"
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "",
    "text": "Hallo allemaal,\nWelkom bij deze post over een tweede brein! Geen zorgen, het is geen brein op water in een potje en het is ook (nog) geen werkzaam brein. Het is een term die komt van Forte Labs (een bedrijf dat zich focust op het verbeteren van je creatieve geest) en simpel gezegd is het een systeem om efficiënt notities van al je geconsumeerde informatie te maken en op te slaan.  \nMaar waarom wil je een tweede brein? Tegenwoordig is er zo veel informatie dat je het niet allemaal kan onthouden (eigenlijk was dat al een lange tijd zo en werden er boeken geschreven, maar met het internet heb je makkelijker toegang tot de vele informatie). Daarom zou het ideaal zijn om een systeem te gebruiken dat veel van de informatie voor jou onthoudt. Dan is het belangrijk om makkelijk bij de juiste informatie te komen, dat is namelijk mijn probleem wanneer ik al mijn notities opsla in schrijfblokken en schriften. Gelukkig hebben we nu hele mooie technische tools waarmee je gemakkelijk je notities kunt opzoeken! In deze post ga ik uitleggen welke technische tools ik gebruik en hoe ik een persoonlijke cloud heb gebouwd om al die data in eigen beheer te hebben (geen last van privacyschendingen). Laten we beginnen."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#inleiding",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#inleiding",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "",
    "text": "Hallo allemaal,\nWelkom bij deze post over een tweede brein! Geen zorgen, het is geen brein op water in een potje en het is ook (nog) geen werkzaam brein. Het is een term die komt van Forte Labs (een bedrijf dat zich focust op het verbeteren van je creatieve geest) en simpel gezegd is het een systeem om efficiënt notities van al je geconsumeerde informatie te maken en op te slaan.  \nMaar waarom wil je een tweede brein? Tegenwoordig is er zo veel informatie dat je het niet allemaal kan onthouden (eigenlijk was dat al een lange tijd zo en werden er boeken geschreven, maar met het internet heb je makkelijker toegang tot de vele informatie). Daarom zou het ideaal zijn om een systeem te gebruiken dat veel van de informatie voor jou onthoudt. Dan is het belangrijk om makkelijk bij de juiste informatie te komen, dat is namelijk mijn probleem wanneer ik al mijn notities opsla in schrijfblokken en schriften. Gelukkig hebben we nu hele mooie technische tools waarmee je gemakkelijk je notities kunt opzoeken! In deze post ga ik uitleggen welke technische tools ik gebruik en hoe ik een persoonlijke cloud heb gebouwd om al die data in eigen beheer te hebben (geen last van privacyschendingen). Laten we beginnen."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#het-tweede-brein",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#het-tweede-brein",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "Het Tweede Brein",
    "text": "Het Tweede Brein\nHet belangrijkste aan het tweede brein is dat het makkelijk te gebruiken is. Het moet gemakkelijk zijn om snel notities te maken en alle notities moeten verzameld worden op 1 plek zodat je op elk apparaat (mobiel, laptop, desktop, e-reader, etc.) ten allen tijde bij al je notities kunt. En als je snel wilt beginnen moet het systeem makkelijk op te zetten zijn.\nIn alle eerlijkheid, de technieken die ik gebruik zijn verre van gemakkelijk op te zetten. Dat komt namelijk omdat ik de laatste tijd privacy belangrijker vind. Hierdoor vallen de technologieën die de data voor je beheren af omdat ik mijn data liever in eigen beheer heb. Als jij privacy minder belangrijk vindt, dan hoef je de manier in deze blogpost niet te gebruiken en kan je andere technologieën kiezen. Maar mocht je privacy wel degelijk zo belangrijk vinden (of je vindt het gewoon cool om zelf een opslag “cloud” te maken) dan hoop ik met deze blogpost het proces te vereenvoudigen!\nDe technologieën die ik heb gekozen voor mijn tweede brein zijn Obsidian en Nextcloud (in plaats van Nextcloud kan je bijvoorbeeld Obsidian Sync of Evernote gebruiken, deze twee oplossingen beheren de data voor jou). Obsidian is een tool om notities te maken en Nextcloud is de tool om de data in op te slaan. Daarnaast zijn er nog wat tools nodig om de technologieën makkelijker te laten werken met bijvoorbeeld mobiele apparaten. Deze tools zijn MacroDroid, Syncthing en Readwise (ook de Reader). Deze laatste drie tools (Syncthing, Readwise en de Reader) zijn niet de focus van deze post, dus er komt nog een vervolg!  \nObsidian is relatief makkelijk in te stellen en te installeren. Helaas is Nextcloud wat ingewikkelder. Deze tool moet je namelijk ook beschikbaar maken via het internet (ik heb gekozen om alleen op mijn lokale netwerk bij de data te kunnen). Als eerste heb je een DNS Record nodig. Dan host je een reverse proxy zodat je via HTTPS kunt communiceren (Nginx). Vervolgens draai je Nextcloud op een server thuis (bijvoorbeeld zoals ik dat heb gedaan op een Raspberry Pi). De laatste stap is het configureren van de applicaties zodat je via je domein bij de Nextcloud app kan komen."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#dns-record",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#dns-record",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "DNS Record",
    "text": "DNS Record\nEen DNS record is nodig om een domein (of subdomein) te laten wijzen naar je publieke IP adres (te vinden via https://www.whatismyip.com). Hierdoor kan je straks je Nextcloud server benaderen via het Wereldwijde Web. Nu heb ik zelf al een domein (waar je deze post op leest) en heb ik een subdomein gebruikt om naar het ip-adres te wijzen. Maar als je geen domein hebt, kan je ook een gratis subdomein gebruiken van bijvoorbeeld DuckDNS (dat is gratis, zelf ben ik huiverig met gratis. Vaak doen ze dan iets met je data, ook al zeggen ze van niet. Dus voordat je DuckDNS gebruikt, onderzoek goed wat ze precies doen!). Vervolgens maak je een record (bijvoorbeeld een A (Alias) record) zoals hieronder in de afbeelding."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#nginx-proxy",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#nginx-proxy",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "Nginx Proxy",
    "text": "Nginx Proxy\n\nDocker\nTegenwoordig is het draaien van applicaties zoals Nginx makkelijk gemaakt door het gebruik van Docker containers. Ik wil niet uitvoerig ingaan op wat een container is maar hier een quote van Docker Website\n\n”A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another”\n\nDus Docker moet geinstalleerd worden, en in dit artikel staat uitgelegd hoe je Docker kunt installeren op je Pi.\n\n\nPortainer\nVervolgens adviseer ik om Portainer te installeren. Portainer kan, net als Docker, zelf weer het beste uitleggen wat het is\n\n”Portainer is a universal container management platform that doesn’t lock you into a single technology or vendor”\n\nEn het gemakkelijkste om Portainer te installeren is via Docker, en in dit artikel wordt uitgelegd hoe je dat doet.\nMet Portainer en Docker geïnstalleerd kan er nu een Nginx stack gemaakt worden. Open de Portainer web interface, navigeer naar Stacks en klik op “Add Stacks”. Dan geef je een naam aan de stack: bijvoorbeeld nginx-proxy. En in de Web Editor plak je onderstaande YAML code.\nversion: \"3\"  \n  \nnetworks:  \n  proxy:  \n    external: true  \n  \nservices:  \n  reverse-proxy:  \n    image: \"jc21/nginx-proxy-manager:latest\"  \n    restart: always  \n    ports:  \n      - \"80:80\"  \n      - \"443:443\"  \n      - \"81:81\"  \n    environment:  \n      DB_SQLITE_FILE: \"/data/database.sqlite\"  \n      DISABLE_IPV6: \"true\"  \n    volumes:  \n      - ./data:/data  \n      - ./letsencrypt:/etc/letsencrypt  \n    networks:  \n      - proxy\nWanneer je je stack opslaat dan wordt er op de achtergrond docker compose gebruikt. Vaak wordt dit gebruikt voor multi-container Docker applicaties, maar ik vind het ook een overzichtelijke manier om een single-container applicatie te starten.\nHier een korte uitleg wat er wordt gemaakt in bovenstaande stack. Er wordt 1 service gestart, namelijk de reverse-proxy. Hierin wordt de nginx-proxy-manager docker image gebruikt. Nginx Proxy Manager is een applicatie dat nginx en letsencrypt gebruikt om het zo makkelijk mogelijk te maken om een proxy server met HTTPS capaciteit op te zetten. Deze nginx-proxy wordt verbonden aan het netwerk “proxy” en dit netwerk is external. Dat is belangrijk omdat het netwerk dan ook benaderd kan worden in de Nextcloud stack. Voor meer informatie over de Nginx Proxy Manager kan je hierheen gaan.\nNavigeer naar de Nginx Proxy Manager (als je niks aangepast hebt aan bovenstaande config is dat http://[Lokale IP van Raspberry]:81). Als alles goed is gegaan komt er een inlog scherm waarin je kan inloggen met de volgende standaardwaarden\nEmail:    admin@example.com\nPassword: changeme\nNadat je inlogt met deze gegevens zal je onmiddellijk gevraagd worden om bovenstaande gegevens te wijzigen.\nNu je succesvol bent ingelogd is de volgende stap om de Nextcloud stack werkend te krijgen."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#nextcloud",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#nextcloud",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "Nextcloud",
    "text": "Nextcloud\nOm de Nextcloud applicatie te draaien kan je weer een nieuwe stack aanmaken via Portainer. Deze stack heeft niet alleen de Nextcloud applicatie nodig, maar ook een database. Standaard gebruikt Nextcloud SQLite, maar dat wordt niet aangeraden. Ik kies daarom nu voor een PostgreSQL database (ik weet niet of MariaDB, MySQL of een andere DB beter werkt, maar ik heb ervaring met Postgres en vind het altijd fijn werken en het is open source). Hieronder de YAML code met de stack.\nversion: '3'  \n  \nvolumes:  \n  nextcloud-data:  \n  nextcloud-db:  \n  \n  \nnetworks:  \n  frontend:  \n    name: proxy  \n    external: true  \n        \n  backend:  \n  \n  \nservices:  \n  \n  nextcloud-app:  \n    image: nextcloud  \n    restart: always  \n    ports:  \n      - 8080:80  \n    volumes:  \n      - nextcloud-data:/var/www/html  \n    environment:  \n      - POSTGRES_HOST=nextcloud-db  \n      - POSTGRES_DB=${POSTGRES_DB}  \n      - POSTGRES_USER=${POSTGRES_USER}  \n      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}  \n      - NEXTCLOUD_ADMIN_PASSWORD=${NEXTCLOUD_ADMIN_PASSWORD}  \n      - NEXTCLOUD_ADMIN_USER=${NEXTCLOUD_ADMIN_USER}  \n    networks:  \n      - frontend  \n      - backend  \n  \n  nextcloud-db:  \n    image: postgres  \n    restart: always  \n    volumes:   \n      - nextcloud-db:/var/lib/postgresql/data  \n    environment:  \n      - POSTGRES_USER=${POSTGRES_USER}  \n      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}  \n      - POSTGRES_DB=${POSTGRES_DB}  \n    networks:  \n      - backend\nDeze stack is groter en ik zal weer kort toelichten wat er allemaal wordt gemaakt.\nAls eerste worden er twee volumes gemaakt. Volumes maak je wanneer je de data van een container wilt behouden nadat de container is afgesloten of herstart. Het is belangrijk dat je dit voor Nextcloud doet, want anders ben je al je in de cloud opgeslagen bestanden kwijt wanneer de container stopt. Ook is er een volume voor de database en daarbij geldt hetzelfde.\nVervolgens wordt er gebruik gemaakt van twee netwerken, front-end en back-end. Voor de front-end specificeer je dat het een extern netwerk is met de naam proxy. Dat is het netwerk van de Nginx Proxy Manager stack! Hierdoor kunnen de applicaties die verbonden zijn aan dit netwerk met elkaar communiceren. Dat is nodig, want de Nginx Proxy gaat verkeer doorsturen naar de Nextcloud app. Het is ook goed om netwerken te scheiden, zodat applicaties alleen met elkaar kunnen communiceren als dat nodig is. Daarom is er een back-end netwerk gemaakt dat gebruikt wordt door de database en Nextcloud applicaties maar niet door de Nginx Proxy Manager!\nDan maken we nu de twee applicaties (docker noemt dat services). Als eerste de Nextcloud applicatie.Hierbij zijn een aantal zaken belangrijk:\n\nonthouden welke poort je gebruikt (want deze is nodig voor de Proxy Host)\nom de juiste volume te koppelen om zo je data te behouden\nde juiste netwerken te kiezen (Nextcloud moet zowel met de database als de Nginx Proxy communiceren dus heeft deze applicatie zowel front-end als back-end netwerken nodig)\nom Environment Variabelen in te stellen \n\nDe environment variabelen zijn nodig om Nextcloud te configureren. Omdat er een Postgres DB wordt gebruikt zijn dat dus Postgres variabelen. Daarnaast maken we ook Nextcloud admin inlog gegevens aan (hier is meer informatie over welke environment variablen je kan instellen in deze container).\nZoals je misschien opvalt zijn de waardes van de environment variabelen in dit format\n${POSTGRES_USER}. Met deze syntax probeert Docker de waardes uit de environment variabelen te halen van de plek waar Docker compose wordt gedraaid. Dit doet Portainer voor je, maar dan moet je met het aanmaken van de stack deze wel definiëren. Hier lees je hoe je dit kunt doen met een .env file, maar je kunt ze ook handmatig invoeren bij het aanmaken van de stack (onder de web editor).\nAls laatste in deze stack maak je een Postgres DB. Deze moet verbonden zijn aan het back-end netwerk, aan de db volume. En je moet hier ook weer environment variabelen instellen. Voor meer informatie over de postgres container klik hier.\nNu beide stacks zijn aangemaakt, moeten er nog een aantal configuraties worden gedaan."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#configuraties",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#configuraties",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "Configuraties",
    "text": "Configuraties\n\nNginx Proxy Configureren\nAllereerst de configuratie van de Nginx Proxy. Via de Nginx Proxy Manager is het nodig om een Proxy Host in te stellen. Deze Proxy accepteert het inkomende verkeer en stuurt het door naar de Nextcloud applicatie. Hieronder staan twee screenshots met voorbeeld instellingen.\n\nBelangrijk hierbij is dat je je aangemaakte domeinnaam toevoeg bij de Domain Names en het lokale IP adres van je Raspberry PI (het is daarom aan te raden dat je een statische IP voor je Raspberry Pi instelt). Hier is uitleg hoe je dat kunt doen). En het laatste belangrijke punt is de Forward Port, dit moet de poort zijn waar de Nextcloud applicatie op draait. Deze poort is ingesteld in de Nextcloud stack hierboven en is als je dezelfde YAML hebt gebruikt de poort 8080.\nVervolgens stel je het SSL tabblad in met onderstaande gegevens.\n\nDeze instellingen maken een nieuw SSL certificaat aan, gebruikmakend van Lets Encrypt. Door dan SSL te forceren zal je altijd een versleutelde verbinding hebben wanneer je gegevens op gaat slaan in Nextcloud. Vergeet hier niet je eigen e-mailadres in te vullen.\n\n\nRouter Configureren\nVervolgens moet je router nog zo ingesteld worden dat wanneer er iemand naar je router IP gaat, deze wordt doorverwezen naar je Nginx Proxy manager (en die stuurt het verkeer dan door naar je Nextcloud applicatie). Hiervoor moeten er twee poorten “geforward” worden, namelijk poort 80 (HTTP) en 443 (HTTPS). Hoe je dit doet is voor iedere router verschillend, maar dat ziet er ongeveer uit zoals onderstaande foto.\n\nVoor het IP adres vul je het lokale Raspberry Pi adres in, dan wordt het verkeer naar je router op poort 80 en 443 doorgestuurd naar je Raspberry Pi.\n\n\nNextcloud Configureren\nAls laatste zijn er nog enkele wijzigingen nodig in de Nextcloud configuratie. Hiervoor moet je een PHP configuratie bestand aanpassen in je Nextcloud-data volume. De locatie van de Docker volume op je Raspberry Pi kan je vinden in Portainer door naar Volumes te navigeren en dan (als je dezelfde YAML configuraties heb gebruikt) de “nextcloud_nextcloud-data” te openen. Naast “Mount Path” staat dan de locatie waar het volume is opgeslagen. Hier kan je heen navigeren in je terminal op de Raspberry Pi. De configuratie file die aangepast moet worden is (wanneer je in de Mount Path folder zit):\n\nconfig/config.php\n\nOpen dit bestand met je favoriete editor (bijvoorbeeld vim) en dan moet je de volgende instellingen toevoegen:\n'overwrite.cli.url' =&gt; 'https://&lt;jouw-domein&gt;',\n'overwritehost' =&gt; '&lt;jouw-domein&gt;',\n'overwriteprotocol' =&gt; 'https',\nOok moet je (in deze config file) aan de Trusted Domains array je eigen domein toevoegen."
  },
  {
    "objectID": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#tot-slot",
    "href": "posts/2023-05-15-Raspberry-pi-Nextcloud/index.html#tot-slot",
    "title": "Een Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi",
    "section": "Tot Slot",
    "text": "Tot Slot\nWanneer je het configureren hebt voltooid kan je nu naar je domein navigeren om in te loggen met Nextcloud. Om vervolgens op je verschillende apparaten bij je Nextcloud bestanden te komen hoef je enkel nog Nextcloud te installeren.\nEr zijn dan jammer genoeg een paar problemen… Namelijk dat Nextcloud op je mobiel geen two-way sync heeft, waardoor aanpassingen aan een bestand op je mobiel niet worden gesynchroniseerd naar je Nextcloud app. Ook is er geen snelle manier om een nieuwe notitie te maken met Obsidian op je mobiel, omdat er bijvoorbeeld geen Widgets van de Obsidian app zijn.\nIn een volgende post zal ik uitleggen hoe je deze twee problemen kunt oplossen.\nVoor nu een fijne dag!\nMees"
  },
  {
    "objectID": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html",
    "href": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html",
    "title": "Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian",
    "section": "",
    "text": "Hallo hallo!\nVorige post heb ik verteld hoe je Nextcloud kunt hosten op je Raspberry Pi. In deze post wil ik jullie uitleggen hoe je Nextcloud vervolgens kunt koppelen met een Obsidian vault om deze te synchroniseren met verschillende apparaten. Ook zijn er twee (ik vind het merkwaardige) problemen waarvoor ik ook een oplossing zal bespreken.\nMaar eerst de Obsidian vault in Nextcloud starten!"
  },
  {
    "objectID": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#inleiding",
    "href": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#inleiding",
    "title": "Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian",
    "section": "",
    "text": "Hallo hallo!\nVorige post heb ik verteld hoe je Nextcloud kunt hosten op je Raspberry Pi. In deze post wil ik jullie uitleggen hoe je Nextcloud vervolgens kunt koppelen met een Obsidian vault om deze te synchroniseren met verschillende apparaten. Ook zijn er twee (ik vind het merkwaardige) problemen waarvoor ik ook een oplossing zal bespreken.\nMaar eerst de Obsidian vault in Nextcloud starten!"
  },
  {
    "objectID": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#obsidian-vault-in-nextcloud",
    "href": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#obsidian-vault-in-nextcloud",
    "title": "Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian",
    "section": "Obsidian vault in Nextcloud",
    "text": "Obsidian vault in Nextcloud\nAllereerst is het verstandig om naast het Nextcloud Admin account, ook een los account te maken voor het dagelijkse gebruik. Klik hier om naar de uitleg te gaan om gebruikers toe te voegen.\nWanneer je dat gedaan hebt, heb je zowel de Nextcloud Client als Obsidian nodig op je computer.\nObsidian Download Pagina Nextcloud Client Download Pagina\nNa de installatie log je in met de aangemaakte gebruiker via de URL die je hebt gekozen bij het opzetten van de Nextcloud server. Vervolgens kan je dan een Obsidian vault maken in de Nextcloud map (ik heb een losse map “Obsidian” gemaakt in de Nextcloud map en die gekozen voor de Obsidian vault).\n\nEn dat was het eigenlijk al, wanneer je nu op je laptop ook Obsidian en de Nextcloud client installeert, hoef je alleen nog maar de vault  te openen die in je Nextcloud map zit. Tada, je Obsidian vault wordt nu gesynchroniseerd tussen je laptop en desktop.\nHierboven heb ik het specifiek over een laptop en een desktop, maar ik denk dat het gebruikelijker is om een laptop/desktop te willen synchroniseren met een mobiel apparaat (telefoon of tablet). Dat wil ik namelijk ook! Helaas komen we nu in aanraking met merkwaardig probleem nummer één."
  },
  {
    "objectID": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#merkwaardig-probleem-mobiele-nextcloud-client-synchroniseert-niet-twee-kanten-op",
    "href": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#merkwaardig-probleem-mobiele-nextcloud-client-synchroniseert-niet-twee-kanten-op",
    "title": "Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian",
    "section": "Merkwaardig probleem: Mobiele Nextcloud Client Synchroniseert niet twee kanten op",
    "text": "Merkwaardig probleem: Mobiele Nextcloud Client Synchroniseert niet twee kanten op\nHet probleem is dat de mobiele Nextcloud client, geen synchronisatie heeft die twee kanten op werkt (two-way sync). Hierdoor worden aanpassingen in bestaande bestanden niet opnieuw geüpload naar Nextcloud, waardoor je andere apparaten die updates niet hebben. Ik vind het vervelend dat de mobiele client dat niet kan (hopelijk gaat iemand het ooit maken er is een bounty voor: https://app.bountysource.com/issues/35153835-allow-2-way-sync), maar gelukkig is er wel een manier om dit probleem op te lossen.\nDe oplossing is: nog een andere applicatie, namelijk Syncthing. Met Syncthing kan je verschillende mappen synchroniseren met apparaten die op hetzelfde netwerk zitten. Dit lost bovenstaand probleem op door de map waar je Obsidian vault in zit op je mobiel, te synchroniseren naar je computer. De computer synchroniseert dan wel naar Nextcloud via de Nextcloud Client, omdat die wel two-way sync ondersteunt.\nAllereerst installeer je Syncthing op zowel je laptop als je mobiel (via de Playstore of App Store)\nSyncthing Download Pagina(Ik heb zelf de Base Syncthing gedownload. De uitleg in deze post gaat dus ook over die versie van Syncthing) Synchthing Play Store\nNa de installatie en het starten van Syncthing navigeer je naar http://localhost:8384/ om naar de grafische interface (GUI) van Syncthing te gaan (dat ziet er uit zoals hieronder).\n\nAls eerste moet je op je laptop je mobiel als extern apparaat (remote device) toevoegen. En vervolgens voeg je, op je mobiel, de laptop toe als extern apparaat. Alleen dan is er voor beide apparaten toestemming om met elkaar te synchroniseren. Dit doe je voor je laptop door op “Extern Apparaat Toevoegen” (“Add Remote Device”) in de GUI te klikken en dan het Apparaat ID (van je mobiel, deze is te vinden door de mobiele app te openen, dan linksboven het menu te openen en daar op Show Device ID te klikken) en de naam van het Apparaat in te vullen (let wel op dat beide apparaten op hetzelfde netwerk zitten). Nadat je dat hebt gedaan zal het toegevoegd apparaat onder Externe Apparaten (Remote Devices verschijnen).\nVoor de mobiele app werkt het nagenoeg hetzelfde.\n\nOpen de app\nNavigeer naar devices\nKlik op het plusje (rechtsboven)\nVul hier het Device ID (van je laptop, deze is te vinden door in de GUI op “Acties” (“Actions”) te klikken en dan op “ID weergeven” (“Show ID”)) en “Name” in te vullen.\n\nNu kunnen je laptop en mobiel met elkaar synchroniseren, alleen moet je nog vertellen welke map(pen) ze met elkaar synchroniseren.\nJe begint op je laptop (waar ook Nextcloud opstaat) en in de GUI klik je op “Map Toevoegen” (“Add Folder”). Dan vul je de map waar je Obsidian vault staat in in het “MapLocatie” (“Folder Location”) veld. Vervolgens ga je naar de “Delen” (“Share”) tab en daar vink je je mobiel aan. Tot slot klik je op “Opslaan” (“Save”).\nDan moet je op je mobiel dezelfde folder toevoegen.\n\nOpen de App\nNavigeer naar Folders\nKlik op het plusje (rechtsboven)\nVul bij Folder Label hetzelfde label in als die in de GUI op je laptop\nVink aan met welk apparaat je wilt delen (de naam van je Laptop)\nKies een “Directory” waar je de gedeelde data wilt opslaan (onthoudt deze)\n\nWanneer je deze stappen hebt gevolgd, dan kan je ieder moment dat je mobiel en computer op hetzelfde netwerk zitten, de folders synchroniseren. Je hoeft alleen Syncthing op te starten.\nNu kan je op je mobiel de Obsidian App downloaden en de Obsidian Vault openen die je in bovenstaande folder (stap 6) hebt gekozen om te synchroniseren."
  },
  {
    "objectID": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#merkwaardig-probleem-je-kunt-niet-snel-een-notitie-maken-met-obsidian-mobiel",
    "href": "posts/2023-07-05-Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian/index.html#merkwaardig-probleem-je-kunt-niet-snel-een-notitie-maken-met-obsidian-mobiel",
    "title": "Een Tweede Brein - Oplossen problemen Nextcloud en Obsidian",
    "section": "Merkwaardig probleem: Je kunt niet snel een notitie maken met Obsidian mobiel",
    "text": "Merkwaardig probleem: Je kunt niet snel een notitie maken met Obsidian mobiel\nDan nu naar het tweede merkwaardige probleem, namelijk dat je eerst je telefoon ontgrendelt, dan de Obsidian app moet openen, links boven op het krant (ik weet eigenlijk niet goed hoe je zo een icoontje noemt, maar krant lijkt er het meeste op) icoontje klikken en dan links onder op het papier en potlood icoontje, je typt je notitie en als laatste sluit je de app. Dat zijn te veel handelingen om even snel een notitie te maken van wat je hoort, leest, tegenkomt of herinnert. Jammer genoeg kan je ook geen Obsidian widget instellen. Daarom moet je zelf een (soort van) widget maken.\nHiervoor gebruik je een andere app, namelijk Macrodroid. Macrodroid is een app waarmee je door het klikken van één knop verschillende acties kunt doen, dat heet een macro. Of je kan door één klik een input schermpje openen waarin je een notitie kan typen en wanneer je op “ok” drukt die automatisch toevoegen aan je Obsidian notitie van de dag. Een extraatje is dat je deze knop op je startscherm kunt zetten.  Waardoor je alleen nog deze stappen hoeft te doen:  telefoon ontgrendelen, op de gemaakte widget klikken, notitie typen en dan “ok” je notitie is opgeslagen. Dat maakt opkomende ideeën zoveel makkelijker om op te slaan.\nHieronder staat beschreven hoe je dat zelf kunt instellen op je telefoon.\n\nOpen MacroDroid en klik op “Add Macro”\nGeef de macro een naam. Bijvoorbeeld: Snel Notitie Toevoegen\nStel een trigger in en kies “Shortcut Launched” (zie afbeelding hieronder)\n\n\n\nStel een actie in en kies “Set Variable” en stel deze in (zie afbeeldingen hieronder)\n\n\n\nVoer “input” in als variable name\nKies “String” als variable type\nVink Create variable now aan\nKlik op “OK”\n\n\n\nVink [User Prompt] aan\nKlik op “OK”\n\n\n\nVul een Title naar keuze in\nVink de volgende vakjes aan: “Allow cancel”, “Cancel prevents subsequent actions running” en “Dark mode (als je dat wilt)”\nKlik op “OK”\n\n\n\nVoeg nog een actie toe, “Write to file” en stel in (zie afbeeldingen hieronder)\n\n\n\nBij “Select Folder” kies je je Obsidian folder (ik heb in de Obsidian Vault een folder gemaakt genaamd Inbox. Hierin worden alle notities opgeslagen en die verwerk ik dan 1x in de week)\nVul {year}-{month_digit}-{dayofmonth}.md in bij “filename”. De namen tussen de curly brackets ({}) zijn variabelen en die worden ingevuld door MacroDroid. Het resultaat daarvan is bijvoorbeeld 2023-06-30.md\nVul - [ ] {lv=input} in bij “Enter Text”. Deze regel zorgt ervoor dat er in je nieuwe notitie een nieuwe regel wordt gemaakt die begint met een checkbox. Achter de checkbox komt dan je notitie.\nKies “Append to file” zodat je een nieuwe notitie toevoeg aan de bestaande file en die niet overschrijft waardoor je je oude notities van die dag behoudt.\n\n\n\nJe macro ziet er nu zo uit\n\n\n\nSla de macro op en nu kan je via een Widget de Macro aan je scherm toevoegen.\n\n\nVoeg een Widget toe\nKies “MacroDroid Custom”\nSelecteer de gemaakte Macro\n\nTada, nu heb je een makkelijke manier om notities toe te voegen aan Obsidian!\nMet deze twee extra applicaties is het dus mogelijk om de twee tekortkomingen van Nextcloud en Obsidian op te lossen. Ik hoop zelf dat er in de toekomst updates van beide applicaties komen zodat je niet nog twee extra apps nodig hebt. Maar tot die tijd is dit een fantastische oplossing.\nVeel plezier en tot de volgende keer :)\nMees"
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "",
    "text": "Al meerdere keren dit jaar heb ik gehoord dat Rust een interessante programmeertaal is. Dat begon bij het advies van een oud collega, tot het horen van Polars bij Xomnia en verschillende video’s van ThePrimeagen . Daardoor begon het bij mij te kriebelen en wilde ik een klein project beginnen om kennis te maken met Rust."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#inleiding",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#inleiding",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "",
    "text": "Al meerdere keren dit jaar heb ik gehoord dat Rust een interessante programmeertaal is. Dat begon bij het advies van een oud collega, tot het horen van Polars bij Xomnia en verschillende video’s van ThePrimeagen . Daardoor begon het bij mij te kriebelen en wilde ik een klein project beginnen om kennis te maken met Rust."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#waarom-een-minecraft-discord-bot",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#waarom-een-minecraft-discord-bot",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "Waarom Een Minecraft Discord Bot",
    "text": "Waarom Een Minecraft Discord Bot\nOp zoek naar kleine beginnersprojecten vond ik dat het maken van een Discord bot een goed idee kan zijn. Daarnaast heeft een vriend van mij een YouTube kanaal MeneerKB met een Discord server voor zijn community. Hij maakt Minecraft video’s en op zijn server heb ik advies gevraagd naar een idee voor wat handig is om met de Minecraft Discord bot te gaan doen. Zij kwamen met het advies om een bot te maken die je naar het recept van een item kunt vragen en die een overzichtelijk tabel met de ingrediënten terug geeft. Voordat we daaraan beginnen (dat zal in de volgende post zijn), wil ik eerst nog terugkomen waarom Rust een interessante taal is en hoe je ChatGPT kunt gebruiken om een nieuwe taal te leren."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#waarom-rust",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#waarom-rust",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "Waarom Rust",
    "text": "Waarom Rust\nZoals iedere programmeertaal heeft Rust zijn voor- en nadelen. Dit is mijn persoonlijke lijst met belangrijke voor- en nadelen, maar wees ervan bewust dat er vast nog andere voor- en nadelen zijn.\n\nVoordelen van Rust\n\nRust is snel\nRust is een programmeertaal die dichter bij de machine taal (de taal die computer hardware spreekt) ligt dan bijvoorbeeld Python.\n\nDit wordt vaak een “lagere” taal genoemd, ten opzichte van Python wat dan een “hogere” taal is.\n\nHierdoor kan je je code specifiek voor stukken hardware maken zonder dat er functionaliteiten zijn ingebouwd die je niet nodig hebt. Omdat deze functionaliteiten niet zijn ingebouwd moet je meer zelf doen, maar daardoor mis je onnodige functionaliteiten waardoor je programma sneller is. Hierdoor kan je bijvoorbeeld efficiënter het geheugen beheren dat je programma gebruikt. Maar wees je er bewust van dat het daardoor ook makkelijker is om een bug in je programma te introduceren. Het mooie aan Rust is dat ze daar een oplossing voor hebben gevonden.\n\n\nRust heeft de Borrow Checker\nDe Borrow Checker is een tool die onderdeel is van de Rust compiler. Deze tool doet tijdens het compilen een controle van je code, waarin het controleert of je het geheugen van je programma correct beheert. Hiermee zorgt Rust ervoor dat je zelf het geheugen kunt beheren, en dus snellere programma’s maakt, terwijl je van fouten wordt behoed en geen onveilige situaties creëert zoals een Buffer Overflow.\n\n\n\nNadelen van Rust\nDe uitdrukking, ieder voordeel heeft zijn nadeel, heeft ook zijn betrekking op Rust en eigenlijk alle programmeertalen (daarom zullen er vast honderden programmeertalen zijn), maar dit zijn de door mij gekozen belangrijkste nadelen.\n\nRust is moeilijk\nOmdat Rust een “lagere” taal is, en je dus specifieke instructies kunt geven ten opzichte van bijvoorbeeld Python, is het ingewikkelder. Je moet namelijk zelf meer en beter begrijpen wat er met je code gebeurt, omdat er maar weinig vangnetten zijn ingebouwd. En zelfs met de Borrow Checker als vangnet is het nog lastig. Bijvoorbeeld: met het beheren van geheugen komen er (nieuwe) termen zoals pointers, heap en stack om de hoek kijken. Zeker als je vooral bekend bent met “lagere” programmeertalen zoals Python, hoef je je over die termen normaliter geen zorgen te maken, want dat doet Python voor je.\n\n\nRust is minder geschikt voor prototypes\nVaak is het belangrijk om snel te bouwen, omdat je dan snel feedback kunt krijgen op je product. Daarom wordt er vaak gezegd om een Minimal Viable Product (MVP) te bouwen. Maar omdat Rust een “lagere” taal is, komt er meer bij kijken bij het maken van een product dan een “hogere” taal. Gelukkig zijn er al aardig wat Crates (equivalent van packages) die je veel werk uit handen nemen, maar ik denk nog steeds dat je langer bezig zult zijn met Rust dan bijvoorbeeld Python.\nMijn advies hier: bouw een prototype in je favoriete taal. En merk je dat je meer efficiëntie nodig hebt, schrijf die delen in Rust.\n\n\nRust is nieuw\nHoewel Rust er alweer een tijdje is (8 jaar sinds de release) is het nieuwer ten opzichte van Python en C++. Hierdoor zijn er minder libraries (Crates) en sommige features zijn nog niet ontwikkeld (misschien zijn die ook helemaal niet nodig, tot dusver miste ik nog niets). Daarnaast zijn er door de moeilijkheid en nieuwigheid ook minder mensen die Rust kunnen. Daarom denk ik dat Rust voor grotere organisaties (die al problemen hebben met het werven van goede developers) nog geen goede keuze is.\n\n\n\nPersoonlijke Redenen Om In Rust Te Programmeren\nBovenstaande voordelen en nadelen gelden in het algemeen, maar uiteindelijk draait het erom wat je zelf belangrijk vindt. In mijn geval wil ik juist die moeilijke termen zoals pointers, de heap en de stack leren. En ik denk dat in de wereld van Big Data, efficiëntie zeer belangrijk is. Niet alleen omdat het dan sneller is, maar ook omdat het dan minder kost en minder computerkracht en elektriciteit verbruikt. En deze zaken wil ik dan het liefste leren en toepassen in een taal die gericht is op de toekomst en ik denk dat Rust dat is."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#hoe-maak-je-een-discord-bot-in-rust",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#hoe-maak-je-een-discord-bot-in-rust",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "Hoe Maak Je Een Discord Bot In Rust",
    "text": "Hoe Maak Je Een Discord Bot In Rust\n\nDe Rust Tools\nHoewel deze post niet volledig gewijd is aan het maken van een Discord bot en de volgende post in meer detail hierop in zal gaan. Wil ik jullie niet onthouden van de twee tools die ik heb gebruikt voor de bot. De twee belangrijkste Crates zijn Serenity en Shuttle .\n\nSerenity\nIk denk dat de README.md het het korste uitlegt met deze zin\n\nSerenity is a Rust library for the Discord API\n\nEen beetje kort door de bocht betekent dit dat je deze package kunt gebruiken om met Discord te communiceren en dus ook met je Discord Bot. Deze package maakt het dus makkelijker om een Discord Bot te maken.\n\n\nShuttle\nMet Shuttle kan je heel makkelijk Rust apps deployen (online zetten voor de wereld), maar het doet nog meer dan dat: het maakt het ook makkelijker om een applicatie lokaal te draaien en voegt ook een handige manier om met Secrets te werken toe.\n\n\n\nChatGPT Gebruiken om Rust te Leren\nZoals eerder vermeld: Rust is voor mij een nieuwe taal en ik weet veel eigenschappen van de taal nog niet. Maar door wat programmeer-ervaring weet ik vaak wel hoe en wat ik kan en wil bereiken met een stukje code. De antwoorden van jouw eigen hoe en wat vragen zijn perfecte startpunten om ChatGPT code te laten maken.\nIk begin vaak met ChatGPT een generieke vraag te stellen, dit doe ik zodat ChatGPT beter de context begrijpt waar de vraag over gaat.\nBijvoorbeeld:\nHi ChatGPT, I am a Rust beginner and don't know the idiomatic way to program in Rust. Can you help me write that code?\nChatGPT geeft antwoord dat het natuurlijk kan helpen, soms met wat extra informatie. Vervolgens stel ik de vraag die ik beantwoord wil hebben.\nBijvoorbeeld:\nI have a dictionary called recipes, with the recipe name as key and the ingredients as values. I want an idiomatic way to retrieve the ingredients when they exist otherwise I want to show a message that the recipe does not exist.\nEn dit is het resultaat:\nfn get_ingredients(recipes: &std::collections::HashMap&lt;&str, Vec&lt;&str&gt;&gt;, recipe_name: &str) -&gt; Result&lt;&Vec&lt;&str&gt;, &'static str&gt; {\n    match recipes.get(recipe_name) {\n        Some(ingredients) =&gt; Ok(ingredients),\n        None =&gt; Err(\"Recipe not found\"),\n    }\n}\n\nfn main() {\n    // Example dictionary (HashMap) of recipes\n    let mut recipes = std::collections::HashMap::new();\n    recipes.insert(\"Pasta\", vec![\"Noodles\", \"Sauce\", \"Cheese\"]);\n    recipes.insert(\"Salad\", vec![\"Lettuce\", \"Tomato\", \"Cucumber\"]);\n\n    // Example usage\n    match get_ingredients(&recipes, \"Pasta\") {\n        Ok(ingredients) =&gt; {\n            println!(\"Ingredients for Pasta: {:?}\", ingredients);\n        }\n        Err(message) =&gt; {\n            println!(\"Error: {}\", message);\n        }\n    }\n\n    // Trying to get ingredients for a non-existent recipe\n    match get_ingredients(&recipes, \"Pizza\") {\n        Ok(ingredients) =&gt; {\n            println!(\"Ingredients for Pizza: {:?}\", ingredients);\n        }\n        Err(message) =&gt; {\n            println!(\"Error: {}\", message);\n        }\n    }\n}\nAan deze code van ChatGPT kun je zien dat je veel kunt leren. Zo zie je dat het programma in de main functie is geschreven. Dat i.p.v een dictionary er een HashMap is gebruikt (wat dus eigenlijk een dictionary is in Rust). En je ziet bijvoorbeeld een veel gebruikte Rust eigenschap match (voor Pattern Matching). En als laatste zie je Ok() en Err(). Allemaal Rust termen die voor mij als beginner nog onbekend zijn, maar waar ik op deze manier kennis mee leer maken.\nSommige van deze termen zal je direct begrijpen, maar andere termen niet. Gelukkig kan ChatGPT direct antwoorden geven op de termen die je niet begrijpt.\nPrompt:\nWhat does Ok() do in Rust?\nAntwoord:\nIn Rust, `Ok()` is a variant of the `Result` type. The `Result` type is used for functions that may return an error. It has two variants: `Ok(T)` for a successful result with a value of type `T`, and `Err(E)` for an error with a value of type `E`.\n\nHere's a brief explanation:\n\n- `Ok(T)`: Represents the successful result of a computation, where `T` is the type of the value that the computation produces. It's a convention in Rust to use `Ok` for the \"happy path\" or successful outcome.\n    \n- `Err(E)`: Represents an error that occurred during the computation, where `E` is the type of the error. This variant is used to carry information about the error.\n    \n\nWhen you see `Ok(value)` in Rust, it means that the operation was successful, and `value` contains the result of that successful operation. For example:\nfn divide(a: f64, b: f64) -&gt; Result&lt;f64, &'static str&gt; {\n    if b == 0.0 {\n        // Return an error if attempting to divide by zero\n        Err(\"Cannot divide by zero\")\n    } else {\n        // Return the result if the division is successful\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    // Example usage\n    match divide(10.0, 2.0) {\n        Ok(result) =&gt; {\n            println!(\"Result of division: {}\", result);\n        }\n        Err(error) =&gt; {\n            println!(\"Error: {}\", error);\n        }\n    }\n}\nIn this example, if the division is successful, `divide` returns `Ok(result)`, where `result` is the result of the division. If there's an error (e.g., attempting to divide by zero), it returns `Err(\"Cannot divide by zero\")`.\n\nThe `match` statement in the `main` function is then used to pattern match on the result and handle the successful and error cases accordingly.\n\nSo, in short, `Ok()` is a way to wrap a successful result in the `Result` type.\nDit maakt ChatGPT een fantastische leerpartner (bedankt ChatGPT dus ook even voor de antwoorden nadat je klaar bent).\nEr is ook nog een andere manier om ChatGPT te gebruiken. Namelijk om je code te verbeteren en uit te leggen waarom de code dan beter is. Ik begin dan met deze prompt om ChatGPT context mee te geven:\nPrompt:\nHi there you are an Elite Rust programmer and I am your apprentice. I am going to show you pieces of code that I would like you to explain, improve and explain these improvements. Can you do that for me?\nOm vervolgens je code erin te plakken. En voila, je persoonlijke programmeer mentor.\nAls laatste nog een waarschuwing: wees voorzichtig met het gebruiken van ChatGPT. ChatGPT geeft namelijk altijd antwoorden terug. Maar helaas kloppen deze antwoorden niet altijd. Daarom is het goed om sceptisch naar de antwoorden te kijken en deze altijd te beoordelen. Want als er iets bijvoorbeeld te goed klinkt om waar te zijn, is dat waarschijnlijk ook zo. En hoewel dit minpunt vervelend is, is ChatGPT nog steeds een fantastisch hulpmiddel."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#uitdagingen-in-rust",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#uitdagingen-in-rust",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "Uitdagingen In Rust",
    "text": "Uitdagingen In Rust\nAls je niet bekend bent met de “lagere” talen (zoals ikzelf) dan is vooral het geheugen beheren lastig. Normaliter hoef je je daar ook niet druk over te maken, maar omdat je dat niet doet gebruik je veel ingebouwde programmatuur waardoor je programma ook langzamer is. Dat is anders in Rust, doordat je moet nadenken over Pointers en andere geheugenzaken. En daardoor moet je ietwat anders denken als je in Rust programmeert, wat het lastiger maakt. Maar gelukkig is er dan de Borrow Checker die je daarbij helpt. Wat Rust een goede taal maakt om je daaraan te wagen."
  },
  {
    "objectID": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#conclusie",
    "href": "posts/2023-11-29-Minecraft-Bot-Rust-Deel-1/index.html#conclusie",
    "title": "Een Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT",
    "section": "Conclusie",
    "text": "Conclusie\nIn deze post heb je hopelijk geleerd waarom Rust een interessante taal is om te leren en hoe je ChatGPT kunt gebruiken om dat te doen. Daarnaast is er (heel erg) kort uitgelegd hoe je Serenity en Shuttle kunt gebruiken om een Discord Bot te maken in Rust. In de volgende post wordt er dieper in het daadwerkelijk maken van de bot gedoken.\nVoor nu, bedankt voor het lezen en fijne dag!\nMees"
  },
  {
    "objectID": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html",
    "href": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html",
    "title": "Een Flutter App - Deel 2 - Voorbereiden App Structuur",
    "section": "",
    "text": "Hallo allemaal!\nLeuk dat jullie hier weer zijn om dit project te volgen. In deze post neem ik jullie mee in de planning voor de codestructuur van de app die ik aan het maken ben. Omdat dit mijn eerste eigen Flutter project is, neem ik veel informatie over van andere bronnen. Hierdoor leer je op een andere manier (dan je automatische piloot) kijken naar het opzetten van projecten. En wanneer dit bevalt kan je dat uiteraard inbouwen in je automatische werkwijze voor je volgende projecten!"
  },
  {
    "objectID": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html#footnotes",
    "href": "posts/2022-07-27-Flutter-app-deel-2-app-architectuur/index.html#footnotes",
    "title": "Een Flutter App - Deel 2 - Voorbereiden App Structuur",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAndroid App in Flutter Deel 1 - Voorbereiding↩︎\nCode With Andrea App Development Worklfow↩︎\nBloclibrary - Flutter Todos Tutorial↩︎\nGithub Project Board - Flutter App↩︎"
  },
  {
    "objectID": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html",
    "href": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html",
    "title": "Een Flutter App - Deel 6 - Notificaties",
    "section": "",
    "text": "In de vorige Flutter App post is het raamwerk van de Best Practices App opgezet. Maar voor het Minimum Viable Product af is, dient de app iedere ochtend een notificatie te geven dat er een nieuwe practice klaar staat. In deze post wordt beschreven hoe je dat kunt doen."
  },
  {
    "objectID": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#inleiding",
    "href": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#inleiding",
    "title": "Een Flutter App - Deel 6 - Notificaties",
    "section": "",
    "text": "In de vorige Flutter App post is het raamwerk van de Best Practices App opgezet. Maar voor het Minimum Viable Product af is, dient de app iedere ochtend een notificatie te geven dat er een nieuwe practice klaar staat. In deze post wordt beschreven hoe je dat kunt doen."
  },
  {
    "objectID": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#flutter-local-notifications-package",
    "href": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#flutter-local-notifications-package",
    "title": "Een Flutter App - Deel 6 - Notificaties",
    "section": "Flutter Local Notifications Package",
    "text": "Flutter Local Notifications Package\nGelukkig hoef je het notificatiedeel niet helemaal vanaf nul te bouwen. Er is namelijk een aantal packages die het meeste vuile werk al voor je opknappen. Voor deze app is ervoor gekozen om de flutter_local_notifications package te gebruiken. Deze package is gekozen omdat het de meeste likes heeft, een Flutter favourite is, en het redelijk actief onderhouden wordt (Het nadeel van deze package is dat het niet voor het web werkt, maar gelukkig wel voor Android en iOS  (het is mij tot dusver nog niet gelukt om het voor het web werkend te krijgen, misschien een keer leuk om dat voor de community te maken?)."
  },
  {
    "objectID": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#de-interface",
    "href": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#de-interface",
    "title": "Een Flutter App - Deel 6 - Notificaties",
    "section": "De Interface",
    "text": "De Interface\nHet is vaak niet verstandig om de code van een package rechtstreeks te gebruiken. Want wanneer je dan van package wilt veranderen, moet je overal waar je deze package gebruikt hebt de code wijzigen. Het is daarom verstandiger om je package te verpakken (wrappen) door een eigen klasse. Zelf noemde ik dit altijd een Wrapper, maar tijdens het schrijven van deze post heb ik gegoogled op dit concept en kwam ik te weten dat Martin Fowler dit een Gateway noemt. Dit is wat Martin Fowler over een Gateway zegt:\n\nAn object that encapsulates access to an external system or resource.\n\nEen ander voordeel van een Gateway is dat je alleen de functionaliteiten van de package die je nodig hebt kan verpakken. Met de Gateway maak je de overbodige functionaliteiten  onbereikbaar. Alleen wat heb je dan wel nodig? Dat kan je vastleggen in de interface van je Gateway.\nIn de interface bepaal je dus wat je nodig hebt voor je applicatie. In het geval van deze app zijn er eigenlijk maar twee dingen nodig (en dit kan natuurlijk nog veranderen wanneer er meer features bij de app komen).\n\nJe moet een nieuwe notificatie kunnen instellen.\nJe moet kunnen achterhalen of er al een notificatie is ingesteld.\n\nIn Dart gebruik je de term abstract om een interface te maken. Wanneer je dan inherit van die abstracte klasse word je door de compiler gewaarschuwd dat je de methodes in de abstracte klasse moet implementeren. Hieronder staat de code van de abstracte klasse INotificationsApi.\nabstract class INotificationsApi {\n    const INotificationsApi();\n\n    // Returns if a Notification of the API is pending\n    Future&lt;bool&gt; get isNotificationPending;\n\n    /// Set a new notification\n    Future&lt;void&gt; setNotification(\n    String message,\n    DateTime notificationDate,\n    );\n}\nNadat de interface gemaakt is, is het tijd voor de implementaties."
  },
  {
    "objectID": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#de-implementaties",
    "href": "posts/2023-09-18-Flutter-app-deel-6-Notificaties/index.html#de-implementaties",
    "title": "Een Flutter App - Deel 6 - Notificaties",
    "section": "De Implementaties",
    "text": "De Implementaties\nHoewel de flutter_local_notifications package ook al per besturingssysteem (OS, Operating System, in dit geval iOS of Android) verschillende implementaties heeft, is het in dit geval toch handig om dat zelf ook te maken. Voor ieder type OS moet je namelijk zelf de initiële configuratie doorgeven. Dit kan je heel goed doen met een Factory.\nDe Factory maakt de juiste klasse op basis van het OS (zie code hieronder).\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\nimport 'package:notification_api/notification_api.dart';\n\nimport 'android_local_notification_api.dart';\nimport 'ios_local_notification_api.dart';\n\n\nabstract class LocalNotificationApi extends INotificationsApi {\n\n    factory LocalNotificationApi(String platform, String notificationTitle,\n        FlutterLocalNotificationsPlugin notificationsPlugin) {\n\n            switch (platform) {\n                case 'android':\n                    return AndroidLocalNotificationApi(\n                        notificationsPlugin, notificationTitle);\n                case 'iOS':\n                    return IosLocalNotificationApi(notificationsPlugin, notificationTitle);\n                default:\n                    throw UnsupportedError('No NotificationApi implemented for this platform.');\n\n            }\n    }\n\n    Future&lt;void&gt; configureLocalTimeZone();\n}\nVervolgens zorg je voor beide implementaties. Je kunt in de implementaties allerlei methodes en attributen toevoegen, zolang je maar de abstract klasse overschrijft en dus de methodes die gedefinieerd zijn in die klasse implementeert (zie code hieronder voor het Android voorbeeld).\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\nimport 'package:flutter_native_timezone/flutter_native_timezone.dart';\nimport 'package:local_notification_api/src/local_notification_api.dart';\nimport 'package:notification_api/notification_api.dart' as api;\nimport 'package:timezone/data/latest_all.dart' as tz;\nimport 'package:timezone/timezone.dart' as tz;\n\nclass AndroidLocalNotificationApi implements LocalNotificationApi {\n    final FlutterLocalNotificationsPlugin notificationsPlugin;\n    final String notificationsTitle;\n    final Future&lt;String&gt; localTimeZone;\n\n\n\n    AndroidLocalNotificationApi(this.notificationsPlugin, this.notificationsTitle)\n    : localTimeZone = FlutterNativeTimezone.getLocalTimezone() {\n\n    // initialise the plugin. app_icon needs to be a added as a drawable resource to the Android head project\n    const AndroidInitializationSettings initializationSettingsAndroid  = AndroidInitializationSettings('app_icon');\n\n    const InitializationSettings initializationSettings = InitializationSettings(\n    android: initializationSettingsAndroid,\n    );\n\n    notificationsPlugin.initialize(initializationSettings,);\n\n    _requestPermission();\n    configureLocalTimeZone();\n\n    }\n\n    @override\n    Future&lt;bool&gt; get isNotificationPending async {\n        final pendingNotifications = await getPendingNotifications();\n\n        return pendingNotifications\n        .where((notification) =&gt; notification?.title == notificationsTitle)\n        .isNotEmpty;\n    }\n\n    Future&lt;bool?&gt; _requestPermission() async {\n        return notificationsPlugin\n        .resolvePlatformSpecificImplementation&lt;\n        AndroidFlutterLocalNotificationsPlugin&gt;()\n        ?.requestPermission();\n    }\n\n\n\n    Future&lt;List&lt;api.PendingNotifications?&gt;&gt; getPendingNotifications() async {\n    final List&lt;PendingNotificationRequest&gt; pendingNotificationRequests = await notificationsPlugin.pendingNotificationRequests();\n\n    return pendingNotificationRequests.map(\n        (notification) =&gt; api.PendingNotifications(\n            id: notification.id,\n            title: notification.title,\n            body: notification.body,\n    )).toList();\n    }\n\n\n\n    @override\n    Future&lt;void&gt; setNotification(\n        String message,\n        DateTime notificationDate,\n    ) async {\n        const AndroidNotificationDetails androidPlatformChannelSpecifics =\n        AndroidNotificationDetails(\n        'daily_practices_channel', 'daily_practices_channel',\n        channelDescription:\n        'daily practices give a notification once a day',\n        importance: Importance.max,\n        priority: Priority.high,\n        ticker: 'ticker');\n\n        final timeTZ = tz.TZDateTime.from(notificationDate, tz.getLocation(await localTimeZone));\n\n        return await notificationsPlugin.zonedSchedule(\n        UniqueKey().hashCode,\n        notificationsTitle,\n        message,\n        timeTZ,\n        const NotificationDetails(\n            android: androidPlatformChannelSpecifics,\n        ),\n        androidAllowWhileIdle: true,\n        uiLocalNotificationDateInterpretation:\n        UILocalNotificationDateInterpretation.absoluteTime,\n        matchDateTimeComponents: DateTimeComponents.time,\n        );\n\n    }\n\n    @override\n    configureLocalTimeZone() async {\n        tz.initializeTimeZones();\n        tz.setLocalLocation(tz.getLocation(await localTimeZone));\n    }\n}\nDat was het alweer voor deze post. Wil je meer informatie over de code? Maak dan een issue aan in de Github Repo. Hier is de code te downloaden tot dit punt. En in de volgende gaan we de hardcoded implementatie vervangen met Bloc.\nOntzettend bedankt voor het lezen :).\nMees"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CabbageMees",
    "section": "",
    "text": "Een Flutter App - Deel 7 - State Toevoegen met Bloc\n\n\nState Management in Flutter met de Bloc Library\n\n\n\nFlutter\n\n\nBloc\n\n\n\n\n\n\n\n\n\nJun 3, 2024\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Rust CLI maken om Custom GPTs te bouwen van een GitHub repository\n\n\nGebruik de Clap crate om CLI te maken in Rust. En leer wat over RAG en Custom GPTs\n\n\n\nRust\n\n\nCLI\n\n\nCustom GPT\n\n\nClap\n\n\n\n\n\n\n\n\n\nMay 13, 2024\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio\n\n\nRust tools voor een Discord Bot en ChatGPT trucjes.\n\n\n\nRust\n\n\nDiscord Bot\n\n\nTokio\n\n\nPoise\n\n\n\n\n\n\n\n\n\nJan 6, 2024\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Minecraft Discord Bot in Rust - Deel 1 - Een Nieuwe Programmeertaal Leren met ChatGPT\n\n\nRust tools voor een Discord Bot en ChatGPT trucjes.\n\n\n\nRust\n\n\nDiscord Bot\n\n\nChatGPT\n\n\n\n\n\n\n\n\n\nNov 29, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 6 - Notificaties\n\n\nGeef je gebruik een notificatie\n\n\n\nFlutter\n\n\nNotificatie\n\n\nFactory\n\n\nGateway\n\n\nflutter_local_notifications\n\n\n\n\n\n\n\n\n\nSep 18, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Tweede Brein - Oplossen problemen Nextcloud en Obsidian\n\n\nLos de two-two sync en snel notitie maken problemen op\n\n\n\nRaspberry Pi\n\n\nNextcloud\n\n\nObsidian\n\n\nSynccthing\n\n\nMacroDroid\n\n\n\n\n\n\n\n\n\nJul 5, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Tweede Brein Met Nextcloud en Obsidian Op Een Raspberry Pi\n\n\nHost je persoonlijke cloud om bestanden op te slaan\n\n\n\nRaspberry Pi\n\n\nNextcloud\n\n\nObsidian\n\n\nNginx\n\n\nDocker\n\n\n\n\n\n\n\n\n\nMay 15, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 5 - De simpelste implementatie van de App\n\n\nEindelijk starten met het maken van de app!\n\n\n\nFlutter\n\n\nAndroid\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nSide Project - Combining FastAPI and nbdev\n\n\nEasily write a documented web API\n\n\n\nPython\n\n\n\n\n\n\n\n\n\nNov 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 4 - De Integration Test\n\n\nHet schrijven van een Integration Test in Flutter\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\nCI\n\n\nGithub Actions\n\n\nintegration test\n\n\n\n\n\n\n\n\n\nOct 16, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 3 - CI Nog Geen CD\n\n\nHet opzetten van Continuous Integration pipelines met Github Actions\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\nCI\n\n\nGithub Actions\n\n\n\n\n\n\n\n\n\nSep 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 2 - Voorbereiden App Structuur\n\n\nHoe gaat de code-structuur van de app er uit zien?\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\n\n\n\n\n\n\n\nJul 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nTussenproject - Tour de France Voorpspellen met Machine Learning\n\n\nBest presterende renners van de Tour de France voorspellen\n\n\n\nPython\n\n\nTussenproject\n\n\nAI\n\n\nML\n\n\n\n\n\n\n\n\n\nJul 13, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Flutter App - Deel 1 - Voorbereiding\n\n\nEen Android applicatie maken met Flutter\n\n\n\nFlutter\n\n\nAndroid\n\n\nDevOps\n\n\n\n\n\n\n\n\n\nJun 27, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nEen Nieuwe Stap\n\n\nEen nieuwe stap in het blog avontuur\n\n\n\nDe reis\n\n\n\n\n\n\n\n\n\nJun 7, 2022\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nKwaadaardige moedervlekken herkennen met artificiële intelligentie\n\n\nEen voorbeeld van een AI project dat een biologisch probleem kan oplossen\n\n\n\nProjecten\n\n\nCNN\n\n\nBiologie\n\n\n\n\n\n\n\n\n\nJun 19, 2021\n\n\nMees Molenaar\n\n\n\n\n\n\n\n\n\n\n\n\nWelkom op CabbageMees!\n\n\nWaarom begin ik met bloggen\n\n\n\nDe reis\n\n\nIntroductie\n\n\n\n\n\n\n\n\n\nMay 26, 2021\n\n\nMees Molenaar\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "",
    "text": "Hallo, In de vorige post1 hebben is de integration test geschreven. Nu faalt deze test omdat de app nog niet gemaakt is, maar daar gaat in deze post verandering in komen! Maar, omdat ik (zoveel mogelijk) test driven probeer te werken begint deze post opnieuw met tests… Alleen dit keer zijn het Widget tests. Deze tests lijken in eerste instantie veel op de integration test. Het verschil is dat deze tests losse onderdelen, Widgets, testen in plaats van het geheel (wat we doen met de integration test).\nLaten we beginnen!\nPS: Vind de code hier"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#intro",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#intro",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "",
    "text": "Hallo, In de vorige post1 hebben is de integration test geschreven. Nu faalt deze test omdat de app nog niet gemaakt is, maar daar gaat in deze post verandering in komen! Maar, omdat ik (zoveel mogelijk) test driven probeer te werken begint deze post opnieuw met tests… Alleen dit keer zijn het Widget tests. Deze tests lijken in eerste instantie veel op de integration test. Het verschil is dat deze tests losse onderdelen, Widgets, testen in plaats van het geheel (wat we doen met de integration test).\nLaten we beginnen!\nPS: Vind de code hier"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#widget-tests",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#widget-tests",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "Widget Tests",
    "text": "Widget Tests\nEen widget test2 is een test wat een onderdeel van de User Interface (UI) test. Hetgeen dat er getest gaat worden is wederom gebaseerd op de ruwe schets (hieronder weergeven). En met de widget test, wordt in dat geval ook dezelfde logica getest (mede doordat de app nog niet zo complex is).\n\nIn onderstaande Widget test zijn de tests in verschillende groepen verdeelt, omdat dit losse Widgets zijn.\nDe eerste groep is de DailyPracticeApp groep, en die test de Widget DailyPracticeApp. Wanneer je deze weergeeft verwacht ik dat de PracticesPage wordt weergeven. De test werkt als volgt:\n\nJe rendert (weergeven van) de Widget met tester.pumtWidget()\nJe zoekt de PracticesPage wordt weergeven met find.byType()\nJe test de verwachting (expect) dat er 1 Widget met het type PracticesPage is gerendert (findsOneWidget).\n\nIn bovenstaande test zit een structuur.\n\nDe test wordt voorbereid (in dit geval door je Widget te renderen)\nJe zoekt iets (de PracticesPage)\nJe test je verwachting\n\nDeze structuur wordt Arrange, Act en Assert genoemd. Al moet ik zeggen dat Arrange en Act in dit geval zijn samengevoegd tot het renderen van de Widget. Een test die deze structuur beter aanhoud zou de volgende kunnen zijn:\n\nJe rendert een Widget met een knop (Arrange)\nJe voert een actie uit, deze actie is op de knop drukken (Act)\nJe verwacht dat onButtonClick (bijvoorbeeld) 1x wordt uitegevoerd (Assert)\n\nJe zult deze structuur in veel tests terug vinden omdat het structurenen van tests de tests leesbaarder maken!\nDe volgende test groep PracticesPage, test ongeveer hetzelfde, maar dan wordt er getest of er een andere Widget gerenderd wordt (PracticesView). Hierna volger er interessantere tests, namelijk de PracticesView groep.\nIn deze groep wordt er namelijk getest of de app titel en alle practices worden gerenderd. Als eerste de app titel, die vindt je door in de AppBar te kijken (een Widget dat bovenaan je mobiele scherm verschijnt). En daarin te zoeken naar de titel ‘Daily Practices’.\nTot slot, wordt er getest of alle practices in de lijst kunnen gevonden. Maar dit heeft ook wat belemmeringen. Normaliter kan je namelijk alleen testen wat er op dat moment op je scherm verschijnt. Daarom gebruiken we net als in de integration tests de scroll functionaliteit. Dat resulteert in de volgende stappen: * Zoek een Scrollable (dat is de lijst) * Controleer of de eerste practice is gerenderd * Scroll door tester.fling() te gebruiken (let op: je moet je scherm dan verversen door tester.pumpAndSettle() aan te roepen) * Test of de laatste practice is gerenderd\nVervolgens wordt dezelfde tactiek gebruikt om te testen of er 1 actieve practice is. Maar hiervoor wordt er aan de actieve practice een speciale Key meegeven waarop gezocht kan worden. Dat wordt gebruikt om net zo lang te scrollen totdat de actieve practice in beeld is.\nDit waren de Widget testen! Op dit moment zullen ze falen en dat kan je zien door\n\nflutter test\n\nuit te voeren! Omdat er verder geen functionaliteit in de basis app hoeft te zitten kan er eindelijk aan de app gewerkt worden!\nPS: Ik heb van een collega geleerd om je groepen en tests op de volgende manier te benoemen:\n\nDe buitenste groep is de class of functie naam die je wilt testen\n\nDan schrijf je in de test wat die moet doen, dan kan je namelijk de groep en de test lezen als 1 zin.\n\nBijvoorbeeld: DailyPracticeApp, renders PracticesPage\n\nMaar wanneer je als in de zin gaat gebruiken, dan maak je een nieuwe groep!\n\nBijvoorbeeld, DailyPracticesApp, (als) je op de knop drukt (dan) render je een succes bericht (de ‘als’ en ‘dan’ schrijf je niet expliciet op)\n\nGroep: DailyPracticesApp\nGroep: je op de knop drukt\nTest: render je een succes bericht\n\n\n\n\nimport 'package:daily_practices_app/features/home/home.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:daily_practices_app/app/app.dart';\n\nvoid main() {\n  group('DailyPracticeApp', () {\n    testWidgets('renders PracticesPage', (tester) async {\n      await tester.pumpWidget(\n        const DailyPracticeApp(),\n      );\n\n      expect(find.byType(PracticesPage), findsOneWidget);\n    });\n\n    group('PracticesPage', () {\n      testWidgets('renders PracticesView', (tester) async {\n        await tester.pumpWidget(\n          const DailyPracticeApp(),\n        );\n\n        expect(find.byType(PracticesView), findsOneWidget);\n      });\n    });\n\n    group('PracticesView', () {\n      Widget buildSubject() {\n        return const MaterialApp(home: PracticesView());\n      }\n\n      testWidgets('renders AppBar with title text', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        expect(find.byType(AppBar), findsOneWidget);\n        expect(\n          find.descendant(\n            of: find.byType(AppBar),\n            matching: find.text('Daily Practices'),\n          ),\n          findsOneWidget,\n        );\n      });\n\n      testWidgets('renders all listitems', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        final listFinder = find.byType(Scrollable);\n        expect(listFinder, findsOneWidget);\n\n        // Verify that the first practice can be found\n        expect(find.text('Sleep eight hours'), findsOneWidget);\n\n        // Scroll to the bottom\n        await tester.fling(\n          listFinder,\n          const Offset(0, -500),\n          10000,\n        );\n        await tester.pumpAndSettle();\n\n        // Verify that the last practice can be found\n        expect(find.text('Deep breathing'), findsOneWidget);\n      });\n\n      testWidgets('one practice should be active', (tester) async {\n        await tester.pumpWidget(buildSubject());\n\n        final listFinder = find.byType(Scrollable);\n        expect(listFinder, findsOneWidget);\n\n        final activeItemFinder = find.byKey(const ValueKey('ActivePractice'));\n\n        // Find the active practice\n        await tester.scrollUntilVisible(\n          activeItemFinder,\n          500.0,\n          scrollable: listFinder,\n        );\n\n        expect(activeItemFinder, findsOneWidget);\n      });\n    });\n  });\n}"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#de-app",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#de-app",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "De App",
    "text": "De App\n\nmain.dart\nDan is nu toch echt het moment, het bouwen van de app. Omdat testen nu geschreven zijn, is het (hopelijk) vrij gemakkelijk om de “echte” code te schrijvenn. Volgens de testen begin je namelijk met het maken van de DailyPracticesApp. Dit doe je door in main.dart de DailyPracticesApp te runnen met runApp().\nEven terug, main.dart en runApp() zijn nieuwe termen. Waarvoor dienen ze eigenlijk?\nWanneer je app start moet het ergens beginnen, dat is je main.dart en daarin de main() functie. Dus wanneer je de app opent, is de main() functie het eerste wat uitgevoerd wordt! Ok, en runApp()? Daarvoor is het belangrijk om te weten hoe Flutter op de achtergrond een app opbouwt. De term Widget is al een aantal keer voorbij gekomen en in Flutter zijn Widgets erg belangrijk. Zo belangrijk dat Flutter alleen maar Widgets kent! En uit deze Widgets onstaat een Widget Tree (zelfs 3 afzonderlijke trees^LINK NAAR VIDEO). Het probleem is dat een boom ergens moet beginnen. Daarvoor zorgt runApp(). Deze functie maakt de app die je uitvoert (in dit geval DailyPracticeApp() wat een Widget is) de root van de Widget Tree. Daarna kan je app zoveel Widgets toevoegen aan de Tree als je maar wilt!\nimport 'package:daily_practices_app/app/app.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const DailyPracticeApp());\n}\n\n\napp.dart\nWanneer de DailyPracticesApp aan de Root is toegevoegd kan je de MaterialApp3 maken. Dit is een handige Widget die veel voor je doet (zie de documentatie voor verdere info). In dit geval zijn er themas mee gegeven voor de kleuren en een home page! Dat is de PracticesPage.\nimport 'package:daily_practices_app/features/home/home.dart';\nimport 'package:flutter/material.dart';\nimport 'package:daily_practices_app/theme/theme.dart';\n\nclass DailyPracticeApp extends StatelessWidget {\n  const DailyPracticeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: FlutterPracticesTheme.light,\n      darkTheme: FlutterPracticesTheme.dark,\n      home: const PracticesPage(),\n    );\n  }\n}\n\n\nhome.dart\nIn de PracticesPage wordt de PracticesView gerenderd (het is de bedoeling dat er nog andere code bijkomt). In de PracticesView wordt er een Scaffold Widget4 aangemaakt waardoor we een titel kunnen toevoegen (AppBar5) en een ListView6 waarin alle practices aan een lijst toegevoegd kunnen worden. De practices zijn Cards7 en 1 van de practices is nu actief (dat wordt voor nu bepaald door een willekeurig getal; code regel 119).\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\n\nconst practices = &lt;Map&lt;String, dynamic&gt;&gt;[\n  {\n    'id': 1,\n    'practice': 'Sleep eight hours',\n  },\n  {\n    'id': 2,\n    'practice': 'Eat two meals instead of three',\n  },\n  {\n    'id': 3,\n    'practice': 'No TV (or YouTube)',\n  },\n  {\n    'id': 4,\n    'practice': 'No junk food',\n  },\n  {\n    'id': 5,\n    'practice': 'No complaining for one whole day',\n  },\n  {\n    'id': 6,\n    'practice': 'No gossip',\n  },\n  {\n    'id': 7,\n    'practice': 'Return an e-mail from five years ago',\n  },\n  {\n    'id': 8,\n    'practice': 'Express thanks to a friend',\n  },\n  {\n    'id': 9,\n    'practice': 'Watch a funny movie or a stand-up comic',\n  },\n  {\n    'id': 10,\n    'practice': 'Write down a list of ideas. The ideas can be about anything',\n  },\n  {\n    'id': 11,\n    'practice':\n        'Read a spiritual text. Any one that is inspirational to you. The bible, the Tao te Ching, anything you want',\n  },\n  {\n    'id': 12,\n    'practice':\n        'Say to yourself when you wake up, \"I am going to save a life today. Keep an eye out for that life you can save',\n  },\n  {\n    'id': 13,\n    'practice': 'Take up a hobby. Do not say you do not have time',\n  },\n  {\n    'id': 14,\n    'practice':\n        'Write down your entire schedule. The schedule you do everyday. Cross out one item and do not do that anymore',\n  },\n  {\n    'id': 15,\n    'practice': 'Suprise someone',\n  },\n  {\n    'id': 16,\n    'practice': 'Think of ten people you are grateful for',\n  },\n  {\n    'id': 17,\n    'practice':\n        'Forgive someone. You do not have to tell them. Just write it down on a piece of paper and burn the paper (or throw it away)',\n  },\n  {\n    'id': 18,\n    'practice': 'Take the stairs instead of the elevator',\n  },\n  {\n    'id': 19,\n    'practice':\n        'When you find yourself thinking of that special someone who is causing you grief, think very quietly, \"No\". If you think of him and (or?) her again, think loudly, \"No!\" Again? Whisper, \"No!\" Again, say it. Louder. Yell it. Louder. And so on',\n  },\n  {\n    'id': 20,\n    'practice': 'Tell someone every day that you love them',\n  },\n  {\n    'id': 21,\n    'practice': 'Do not have sex with someone you do not love',\n  },\n  {\n    'id': 22,\n    'practice': 'Shower. Scrub. Clean the toxins of your body',\n  },\n  {\n    'id': 23,\n    'practice':\n        'Read a chapter in a biography about someone who is an inspiration to you',\n  },\n  {\n    'id': 24,\n    'practice': 'Make plans to spend time with a friend',\n  },\n  {\n    'id': 25,\n    'practice':\n        'If you think, \"Everything would be better of if I were death\" then think. \"That is really cool. Now I can do anything I want and I can postpone this thought for a while, maybe even a few months.\" Because what does it matter now? The planet might not even be around in a few months',\n  },\n  {\n    'id': 26,\n    'practice': 'Deep breathing',\n  },\n];\n\nfinal activePractice = Random().nextInt(26) + 1;\n\nclass PracticesPage extends StatelessWidget {\n  const PracticesPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const PracticesView();\n  }\n}\n\nclass PracticesView extends StatelessWidget {\n  const PracticesView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Daily Practices'),\n      ),\n      body: ListView.builder(\n        padding: const EdgeInsets.all(8),\n        itemCount: practices.length,\n        itemBuilder: (BuildContext context, int index) {\n          if (index == activePractice) {\n            return Card(\n              key: const Key('ActivePractice'),\n              elevation: 3,\n              color: Theme.of(context).colorScheme.primary,\n              child: ListTile(\n                leading: CircleAvatar(\n                  backgroundColor: Colors.white,\n                  child: Text(\n                    practices[index]['id'].toString(),\n                  ),\n                ),\n                title: Text(\n                  practices[index]['practice'],\n                  style: const TextStyle(\n                    color: Colors.white,\n                  ),\n                ),\n              ),\n            );\n          } else {\n            return Card(\n              elevation: 3,\n              child: ListTile(\n                leading: CircleAvatar(\n                  backgroundColor: Theme.of(context).colorScheme.primary,\n                  child: Text(practices[index]['id'].toString()),\n                ),\n                title: Text(practices[index]['practice']),\n              ),\n            );\n          }\n        },\n      ),\n    );\n  }\n}\nAls je dan nu naar main.dart navigeert en op de play knop drukt zal je app starten. Voor voorbeelden om je app te starten, kan je hier kijken duidelijke uitleg vinden.\nDit was de eerste versie van de app! Alleen het is nog niet volgens de MVP, daarvoor moet de app namelijk iedere ochtend een notificatie geven. Hoe je dat kunt doen zal ik gaan omschrijven in de volgende post.\nTot dan!"
  },
  {
    "objectID": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#footnotes",
    "href": "posts/2023-01-08-Flutter-app-deel-5-start-app/index.html#footnotes",
    "title": "Een Flutter App - Deel 5 - De simpelste implementatie van de App",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://cabbagemees.nl/posts/2022-10-16-Flutter-app-deel-4-de-integration-test/↩︎\nhttps://docs.flutter.dev/cookbook/testing/widget/introduction↩︎\nhttps://api.flutter.dev/flutter/material/MaterialApp-class.html↩︎\nhttps://api.flutter.dev/flutter/material/Scaffold-class.html↩︎\nhttps://api.flutter.dev/flutter/material/AppBar-class.html↩︎\nhttps://api.flutter.dev/flutter/widgets/ListView-class.html↩︎\nhttps://api.flutter.dev/flutter/material/Card-class.html↩︎"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "",
    "text": "​​In een app is het cruciaal dat gebruikers de informatie kunnen aanpassen aan hun behoeften. In de huidige implementatie van de Daily Practices App is dit echter nog niet mogelijk. Daarom gaan we in deze post “state” toevoegen aan de app om dit te realiseren.\nIn de laatste Flutter App Post heb ik de dagelijkse notificatie geïmplementeerd. In de post daarvoor heb ik de simpelste versie van de app (MVP) gemaakt, maar deze versie is niet netjes omdat de practices1 tussen de rest van de code staan. Daar komt in deze post verandering in. Zoals uitgelegd in de app structuur post, wilde ik in deze app de bloc library gebruiken om de user-interface, de business-logica en de data van elkaar te scheiden. Ik vind dat de Bloc library meer is dan alleen een code library, want in de documentatie staat ook veel uitleg over een handige structuur om aan te houden. Het doel hiervan is om straks makkelijk van een hardcoded practices implementatie naar een dynamische implementatie te gaan, zonder dat je veel code hoeft aan te passen omdat deze onderdelen van elkaar gescheiden zijn. Maar hoe werkt Bloc?"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#introductie",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#introductie",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "",
    "text": "​​In een app is het cruciaal dat gebruikers de informatie kunnen aanpassen aan hun behoeften. In de huidige implementatie van de Daily Practices App is dit echter nog niet mogelijk. Daarom gaan we in deze post “state” toevoegen aan de app om dit te realiseren.\nIn de laatste Flutter App Post heb ik de dagelijkse notificatie geïmplementeerd. In de post daarvoor heb ik de simpelste versie van de app (MVP) gemaakt, maar deze versie is niet netjes omdat de practices1 tussen de rest van de code staan. Daar komt in deze post verandering in. Zoals uitgelegd in de app structuur post, wilde ik in deze app de bloc library gebruiken om de user-interface, de business-logica en de data van elkaar te scheiden. Ik vind dat de Bloc library meer is dan alleen een code library, want in de documentatie staat ook veel uitleg over een handige structuur om aan te houden. Het doel hiervan is om straks makkelijk van een hardcoded practices implementatie naar een dynamische implementatie te gaan, zonder dat je veel code hoeft aan te passen omdat deze onderdelen van elkaar gescheiden zijn. Maar hoe werkt Bloc?"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#de-basis-van-bloc",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#de-basis-van-bloc",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "De Basis van Bloc",
    "text": "De Basis van Bloc\nDe Business Logic Component (Bloc) is een manier om “state” toe te voegen aan aan app. “State” is een manier om interactiviteit toe te voegen aan je apps. Dus zonder “state” zou je app statisch zijn (saai). Maar het beheren van “state” maakt de app ook complexer om te onderhouden. Daarom is Bloc bedacht, om het beheren van “state” te vereenvoudigen en los te koppelen.\nEen Bloc is een class wat evenementen (events; voorbeelden zijn een klik op een knop of het starten van een app) als input neemt en op basis van het event een state als output geeft. Bijvoorbeeld: voordat je de app start is je scherm leeg. De Bloc krijgt het event “AppStart” binnen en op basis daarvan wordt eerst de state “Loading” teruggestuurd, waardoor je een laad schermpje te zien krijgt. Na het laden wordt de state “Finished”, waardoor je het start scherm te zien krijgt.\nIn de Bloc class wordt dus niet vastgelegd wat er in het scherm te zien is. De Bloc krijgt een event binnen, dan voert de Bloc een stuk code uit (vaak om data op te halen van een Repository) en als laatste stuurt de Bloc een state terug (waarin de opgehaalde data zit).\n\n\n\n\n\n\n\n\nBloc Overview. Credits to https://bloclibrary.dev\n\n\n\nDe user-interface code hoeft dan ook niet te weten hoe de Bloc werkt. Die code hoeft alleen een event te versturen en dan de state omzetten naar een user-interface. Daardoor is de code erg modulair en makkelijk te onderhouden."
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#bloc-implementeren-in-de-daily-practices-app",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#bloc-implementeren-in-de-daily-practices-app",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "Bloc Implementeren In De Daily Practices App",
    "text": "Bloc Implementeren In De Daily Practices App\n\nData\nIn de data-laag haal je de onbewerkte (raw) data op. Vaak zijn dat simpele API’s die Create, Read, Updaten en Delete (CRUD) functionaliteit implementeren. Denk hierbij aan verbindingen met web API’s of de API van een database. Het voordeel van het scheiden van de data-laag is dat het makkelijk is om van bron te veranderen of juist een bron toe te voegen.\nVoor iedere laag heb ik aparte packages gemaakt. Voor de data-laag zijn dat de practices_api en hardcoded_practices_api. De practices_api bevat de interface van hoe de API eruit moet komen te zien. Het is een blauwdruk van een specifieke implementatie en een specifieke implementatie zit in de hardcoded_practices_api. Met deze blauwdruk is het makkelijk om een andere implementatie te maken (iets wat ik later wil doen).\nIn dit geval is de API nog heel simpel en heeft het alleen de functionaliteit om een lijst van practices op te vragen met de getPractices method.\nHier is de implementatie van de hardcoded practices api\n\n\nRepository\nDe repository-laag is een laagje over de data-laag. Hierdoor kan je bijvoorbeeld meerdere data-lagen samen voegen. Daarnaast is de repository ook de plek waar je de onbewerkte data uit de data-laag, transformeert naar de data die je applicatie nodig heeft. De repository-laag is de laag waarmee de Bloc-laag communiceert.\nIn deze app zit de repository in de practices_repository package. Eerlijk gezegd voelt de repository nu nog wat overbodig, want het enige wat het doet is een method met dezelfde naam aanroepen die in een API is gedefinieerd, namelijk getPractices(). Het voordeel van een repository komt vooral later wanneer je verschillende data bronnen wilt samenvoegen en transformeren.\nHier is de implementatie van de repository\n\n\nBloc\nDe Bloc-laag, zoals hierboven uitgelegd, ontvangt events en geeft states terug. De Bloc communiceert met de user-interface (door middel van de events en states). Dit kan je implementeren met de BlocBuilder en BlocProvider.\nAls eerste maak je een Bloc. Afhankelijk van hoe de mappen structuur van je app eruit ziet, maak je een bloc map (in deze app heb ik per scherm een map in features, voor nu alleen home daarin maak ik dan de home bloc).\nVervolgens heb je drie elementen nodig voor je Bloc. 1. Het daadwerkelijke Bloc 2. De events dat een Bloc als input kan krijgen 3. De states die een Bloc kan terug geven\nHieronder is de code van de simpele HomeBloc. Deze Bloc accepteert een enkele event, HomeLoad. En heeft vier mogelijke states:\n\nHomeInitial:voordat er iets is gebeurd.\nHomeLoading: wanneer het Home scherm aan het laden is.\nHomeLoaded: wanneer het laden klaar en succesvol is.\nHomeError: wanneer er een fout is opgetreden tijdens het laden.\nIn mijn ervaring zien de Bloc states er vaak op deze manier uit (initial, loading, loaded en error). Als laatste nog het Bloc zelf. Hierin definieer je welke functie er moet worden uitgevoerd op basis van het event. In die functie emit() je dan de state die je terug wilt sturen.\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:meta/meta.dart';\nimport 'package:practices_repository/practices_repository.dart';\nimport 'package:logging/logging.dart';\n\npart 'home_event.dart';\npart 'home_state.dart';\n\nfinal log = Logger('HomeBlocLogger');\n\nclass HomeBloc extends Bloc&lt;HomeEvent, HomeState&gt; {\n  final PracticesRepository _practicesRepository;\n\n  HomeBloc({required PracticesRepository practicesRepository})\n      : _practicesRepository = practicesRepository,\n        // Start with the HomeInitial state\n        super(const HomeInitial(practices: [])) {\n    // This piece of code tells to call the _onInitial method when a HomeLoad event is dispatched.\n    on&lt;HomeLoad&gt;(_onInitial);\n  }\n\n  void _onInitial(HomeLoad event, Emitter&lt;HomeState&gt; emit) {\n    final practicesStream = _practicesRepository.getPractices();\n\n    practicesStream.listen((practices) {\n      // Emit the HomeLoaded state with the practices\n      emit(HomeLoaded(practices: practices));\n    }).onError((error) {\n      log.severe('Error while loading practices: $error');\n\n      // Emit the HomeError state\n      emit(const HomeError(practices: []));\n    });\n  }\n\n  @override\n  void onEvent(HomeEvent event) {\n    super.onEvent(event);\n    log.fine('Event: $event');\n  }\n\n  @override\n  void onChange(Change&lt;HomeState&gt; change) {\n    super.onChange(change);\n    log.fine('Change: $change');\n  }\n\n  @override\n  void onTransition(Transition&lt;HomeEvent, HomeState&gt; transition) {\n    super.onTransition(transition);\n    log.fine('Change: $transition');\n  }\n\n  @override\n  void onError(Object error, StackTrace stackTrace) {\n    super.onError(error, stackTrace);\n    log.severe('Error: $error');\n  }\n}\nOm de Bloc te laten communiceren met de user-interface gebruik je de BlocBuilder en BlocProvider.\nDe BlocBuilder zorgt ervoor dat een Widget herbouwd wordt nadat de Bloc een state maakt.\nclass PracticesView extends StatelessWidget {\n  const PracticesView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Daily Practices'),\n      ),\n      // When the HomeState changes, BlocBuilder will call build again\n      // It will get the state and based on the state it renders something on the screen\n      body: BlocBuilder&lt;HomeBloc, HomeState&gt;(\n        builder: (context, state) {\n          if (state is HomeInitial) {\n            return const Center(\n              child: Text('Initial'),\n            );\n          } else if (state is HomeLoaded) {\n            return _buildListView(state.practices);\n          } else {\n            return const Center(\n              child: Text('Error while loading practices'),\n            );\n          }\n        },\n      ),\n    );\n  }\n}\nDe BlocProvider is een manier om een Bloc toe te voegen aan de kind-Widgets in de Widget tree. De BlocProvider gebruikt dependency injection. Hierdoor kan een andere Widget makkelijk een Bloc gebruiken.\nclass PracticesPage extends StatelessWidget {\n  final PracticesRepository practicesRepository;\n\n  const PracticesPage({super.key, required this.practicesRepository});\n\n  @override\n  Widget build(BuildContext context) {\n    // Create a BlocProvider and start with the HomeLoad event \n    return BlocProvider(\n      create: (context) =&gt;\n          HomeBloc(practicesRepository: practicesRepository)..add(HomeLoad()),\n      child: const PracticesView(),\n    );\n  }\n}"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#conclusie",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#conclusie",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "Conclusie",
    "text": "Conclusie\nDit was de introductie van Bloc en hoe je dat kunt gebruiken in je Flutter apps. Nu is deze app ook klaar om de practices dynamisch te maken, want de enige wijziging die nodig is, is de data-laag. Heb jij al eens Bloc in je app gebruikt, dan hoor ik graag jou ervaringen in de reacties :).\nTot de volgende keer!\nMees"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#bronnen",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#bronnen",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "Bronnen",
    "text": "Bronnen\n\nBloc Library Basics & Beyond - Felix Angelov Flutter Europe\nBloc Architecture\nComplete Flutter BLoC Tutorial Understanding State Management in Flutter\nConclusion for Guide on Usage of Flutter BLoC\nWhy We Use Flutter_bloc for State Management"
  },
  {
    "objectID": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#footnotes",
    "href": "posts/2024-06-03-Flutter-app-deel-7-Bloc/index.html#footnotes",
    "title": "Een Flutter App - Deel 7 - State Toevoegen met Bloc",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEen practice is een dagelijkse taak en de practices die nu in de app zitten komen uit het boek Choose Yourself! van James Altucher↩︎"
  },
  {
    "objectID": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html",
    "href": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html",
    "title": "Side Project - Combining FastAPI and nbdev",
    "section": "",
    "text": "Note for frequent readers: this blogpost is written in English since I want to share this post with the fastai community\n\nHello everyone,\nIn this post I won’t discuss Flutter as you are used to, but I will go back to my roots: Python. Python is an extremely convenient lanuage since it has hundruds of usefull packages which make you more productive. Here, I will share two awesome packages nbdev1 and FastAPI2. Furthermore. I will show you how to combine these two packages to create an awesome documented web-API."
  },
  {
    "objectID": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html#footnotes",
    "href": "posts/2022-11-27-Side-Project-FastAPI-nbdev/index.html#footnotes",
    "title": "Side Project - Combining FastAPI and nbdev",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://nbdev.fast.ai/↩︎\nhttps://fastapi.tiangolo.com/↩︎\nhttps://fastapi.tiangolo.com/↩︎\nhttps://www.starlette.io/↩︎\nhttps://pydantic-docs.helpmanual.io/↩︎\nhttps://nbdev.fast.ai/↩︎\nhttps://github.com/MeesMolenaar/fastapi-nbdev↩︎\nhttps://github.com/MeesMolenaar/fastapi-nbdev/blob/main/.github/workflows/test.yaml↩︎\nhttps://forums.fast.ai/c/nbdev/48↩︎"
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "",
    "text": "In deze post neem ik jullie mee met de voorbereidingen van het maken van een Android app. Nu zie ik de vraagtekens in je hersenspinsels verschijnen, want je hebt gelijk: een Android app kan van alles zijn. Daarom is de eerste stap bij het maken van een stuk software, zoals een app, belangrijk om te bepalen wat de gebruiker (of klant) wilt. Specifieker nog: welk probleem wil de gebruiker verholpen zien worden?\nIn een team op de werkvloer wordt deze vraag vaak in kaart gebracht door de product owner. Als product owner werk je naar een bepaald doel (bijvoorbeeld 10% meer omzet) van het bedrijf en dit doe je door je software te maken naar de wensen van je (potentiële) gebruikers. Vervolgens zet je deze wensen om in software features (of user stories) en splits je deze op in kleine taken. Daarna buigt het development team zich erover om de technische kant vorm te geven en weer te verdelen in taken. Deze taken worden op een sprint (vaak een periode van 1 - 4 weken) gezet om af te ronden. Door dit proces blijf je altijd werken aan taken die er toe doen voor de klant.\nAanvulling: Tegenwoordig is er wel eens kritiek op bovenstaande aanpak en zou het beter kunnen zijn om het development team zelf de wensen van klanten in kaart te laten brengen. Hierdoor kan het development team rechtstreeks de klant helpen in plaats van te communiceren met een tussenpersoon.\nHet makkelijke aan een eigen project is dat je zelf de klant bent. In dit geval heb ik een probleem en deze wil ik oplossen. Daardoor is het relatief eenvoudig om het probleem vast te stellen, namelijk: er is geen makkelijk te gebruiken Android app om een lijst van taken aan te maken en van deze lijst iedere ochtend 1 willekeurige taak als notificatie binnen te krijgen. (misschien bestaat zo een app wél al, maar ik wil ook graag leren hoe je aan app maakt! :)). Nu dit probleem duidelijk is kan de product owner (wederom ikzelf, ik heb nog niemand aan kunnen nemen door de krapte op de arbeidsmarkt) aan de user stories beginnen.\nWanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen."
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-mvp",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-mvp",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "De MVP",
    "text": "De MVP\nWanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen.\n\n\n\n\n\n\n\nMVP\nVolgende Versie\n\n\n\n\nLijst met hardcoded practices\nLijst dynamisch kunnen aanpassen en opslaan in een database\n\n\n1 willekeurige practice van bovenstaande lijst pakken\nTijd van de notificatie en hoeveel notificaties aanpasbaar maken\n\n\nBovenstaande practice als notificatie geven\nWillekeur als optie kunnen aanvinken\n\n\nNiet 2x dezelfde notificatie achter elkaar\nPractice voor de dag weergeven wanneer je de app opent\n\n\nAlles met unit en functionele tests\n\n\n\nCI/CD pipeline\n\n\n\nVersie controle (Git)\n\n\n\n\nDeze vereisten worden dan door het technische team in taken verdeeld om dit technisch op te lossen. Het is dan fijn wanneer de taken zo klein mogelijk zijn, zodat je iedere dag werkende (en geteste) code kan toevoegen aan je project en je niet hoeft te werken in branches. Belangrijk hierbij is dat de taken zichtbaar zijn, zodat je (bijvoorbeeld) de volgende vragen kunt beantwoorden: Waar wordt aan gewerkt? Loopt er een taak vast? Dit zorgt er mede voor dat je de obstakels kunt oplossen of verbeteren, waardoor je in het vervolg soortgelijke taken sneller kan afronden en daarmee ook sneller de gebruiker (die vaak ongeduldig zijn) kan helpen!"
  },
  {
    "objectID": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-devops-principes-in-dit-project",
    "href": "posts/2022-06-27-Flutter-app-deel-1-voorbereiding/index.html#de-devops-principes-in-dit-project",
    "title": "Een Flutter App - Deel 1 - Voorbereiding",
    "section": "De DevOps principes in dit project",
    "text": "De DevOps principes in dit project\nZoals in de vorige post uitgelegd wil ik mij met ieder project ook bezig houden met de DevOps principes (om daar beter in te worden). Nu voel ik mij niet geschikt om DevOps samen te vatten, maar toch probeer ik het: “DevOps is een werkwijze welke het doel heeft om zo snel en goed mogelijk problemen op te lossen van een gebruiker (met software)”. Een voorbeeld daarvan is de taken zichtbaar maken (zoals hierboven beschreven). Maar er zijn ook vele andere manieren om het DevOps doel te bereiken (daar zijn verschillende boeken over bijvoorbeeld Accelerate van Nicole Forsgen en The DevOps Handbook van Gene Kim). De manieren in dit project om op de DevOps manier te werken wil ik hier graag herhalen:\n\nVergaar en implementeer klant feedback: maak een MVP dat de klant zo snel mogelijk kan beoordelen en jij daardoor kan aanpassen.\nAlles in versie controle (ook configuratie bestanden!)\nCI/CD pipeline. Dat betekent in het kort: na iedere code incheck dat er automatisch testen worden uitgevoerd en wanneer deze testen succesvol zijn uitgevoerd dat deze nieuwe code automatisch in de live software komt.\nWerk in kleine batches/taken opdelen. Het liefste in taken die maximaal in 1 dag af te ronden zijn. Hierdoor hoef je niet in branches te werken.\nMaak je werk zichtbaar! Zelf gebruik ik nu een Trello board (dit ga ik misschien nog veranderen) waarin ik taken kan slepen van todo naar in progress en dan naar done.\n\nEr zijn nog veel meer principes, maar voor dit project focus ik mij op bovenstaande punten.\nVoordat ik deze post afrond wil ik nog melden dat dit de eerste keer is dat ik een android app maak. Dat betekent dat ik op de afgelopen tijd vooral bezig was met het leren van Kotlin voor Android apps. Hiermee ben ik nu klaar. Daarnaast ben ik ook bezig geweest met Flutter. Met Flutter kan je gemakkelijk multi-platform apps maken, wat het een interessante tool maakt. Daarom wil ik deze eerste app met Flutter schrijven om daar beter in te worden.\nTot de volgende keer!\nGeniet van vandaag :)\nMees"
  },
  {
    "objectID": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html",
    "href": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html",
    "title": "Een Flutter App - Deel 4 - De Integration Test",
    "section": "",
    "text": "Goedemiddag! In de vorige post1 heb ik Github Actions opgezet om de unit, widget en integration tests uit te voeren. Deze actions draaien bij iedere code push, maar er worden nog geen tests uitgevoerd want we hebben nog geen tests! Daarom begin ik vandaag met de integration test.\nIn Flutter heb je drie soorten tests: integration, widget en unit tests. Laten we eerst kijken naar de integration tests. Dit zijn tests om de gehele app te testen. Deze test repliceert het gedrag van een gebruiker en is wat mij betreft daarom ook de belangrijkste soort test. Deze tests moeten altijd werken om te garanderen dat je app hetzelfde functioneert. Ten tweede, widget test: dit zijn tests (zoals de naam al doet vermoeden) om widgets, onderdelen van de User Interface (UI) te testen. En als laatste unit tests. Deze tests zijn handig om de werkzaamheid van losse functies of classes te testen. En deze tests zouden zo simpel moeten zijn dat ze zelfs op de pc van je oma kunnen draaien (ben de bron van deze quote kwijt). Maar waarom testen wij eigenlijk?\nPS: Hier is de Github repository"
  },
  {
    "objectID": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html#footnotes",
    "href": "posts/2022-10-16-Flutter-app-deel-4-de-integration-test/index.html#footnotes",
    "title": "Een Flutter App - Deel 4 - De Integration Test",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://cabbagemees.nl/flutter/android/devops/ci/github%20actions/2022/09/27/Flutter-app-deel-3-CI-nog-geen-CD.html↩︎\nhttps://cabbagemees.nl/flutter/android/devops/2022/06/27/Flutter-app-deel-1-voorbereiding.html↩︎\nhttps://github.com/flutter/flutter/tree/main/packages/integration_test#integration_test↩︎\nhttps://api.flutter.dev/flutter/flutter_test/flutter_test-library.html↩︎\nhttps://docs.flutter.dev/cookbook/testing/widget/scrolling↩︎\nhttps://docs.flutter.dev/cookbook/testing/integration/introduction↩︎"
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "",
    "text": "In de vorige post ben ik begonnen met het uitleggen van de voor- en nadelen Rust. Daarnaast heb ik besproken hoe je ChatGPT kunt gebruiken om een nieuwe programmeertaal te leren. In deze post ga ik uitleggen hoe je een Discord Bot kunt maken.\nEr zijn verschillende crates om sneller projecten af te maken omdat deze werk uit handen nemen. Het plan was om voor de Discord bot Serenity en Shuttle te gaan gebruiken. Maar tijdens het maken van de bot kwam ik erachter dat deze twee crates toch niet de juiste waren.\nUiteindelijk zijn het deze crates geworden: * Poise deze crate gebruikt Serenity, dus indirect wordt dat nog wel gebruikt. * Tokio\nIk kwam bij Poise uit omdat die het maken van slash-commands eenvoudiger maakt dan Serenity. En ik stopte met het gebruik van Shuttle, nadat ik vastliep op deze fout:\n\nRuntime error: Failed to verify the version of shuttle-runtime in /Users/meesmolenaar/Brain/Projects/minecraft-recipe-discord-bot/target/debug/minecraft-recipe-discord-bot. Is cargo targeting the correct executable?\n\nIk heb veel tijd gespendeerd aan het oplossen van deze fout, maar tot op heden is de oplossing nog niet gevonden. Omdat ik Shuttle niet meer gebruik, had ik wel een andere runtime nodig. Tokio heeft een veel gebruikte en stabiele asynchrone runtime en is daarom gekozen."
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#intro",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#intro",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "",
    "text": "In de vorige post ben ik begonnen met het uitleggen van de voor- en nadelen Rust. Daarnaast heb ik besproken hoe je ChatGPT kunt gebruiken om een nieuwe programmeertaal te leren. In deze post ga ik uitleggen hoe je een Discord Bot kunt maken.\nEr zijn verschillende crates om sneller projecten af te maken omdat deze werk uit handen nemen. Het plan was om voor de Discord bot Serenity en Shuttle te gaan gebruiken. Maar tijdens het maken van de bot kwam ik erachter dat deze twee crates toch niet de juiste waren.\nUiteindelijk zijn het deze crates geworden: * Poise deze crate gebruikt Serenity, dus indirect wordt dat nog wel gebruikt. * Tokio\nIk kwam bij Poise uit omdat die het maken van slash-commands eenvoudiger maakt dan Serenity. En ik stopte met het gebruik van Shuttle, nadat ik vastliep op deze fout:\n\nRuntime error: Failed to verify the version of shuttle-runtime in /Users/meesmolenaar/Brain/Projects/minecraft-recipe-discord-bot/target/debug/minecraft-recipe-discord-bot. Is cargo targeting the correct executable?\n\nIk heb veel tijd gespendeerd aan het oplossen van deze fout, maar tot op heden is de oplossing nog niet gevonden. Omdat ik Shuttle niet meer gebruik, had ik wel een andere runtime nodig. Tokio heeft een veel gebruikte en stabiele asynchrone runtime en is daarom gekozen."
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#het-begrijpen-van-asynchroon-programmeren-in-rust-met-tokio.",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#het-begrijpen-van-asynchroon-programmeren-in-rust-met-tokio.",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Het begrijpen van asynchroon programmeren in Rust met Tokio.",
    "text": "Het begrijpen van asynchroon programmeren in Rust met Tokio.\nRust heeft een eigen implementatie van asynchroon programmeren ten opzichte van andere programmeertalen. Bijvoorbeeld: Rust heeft geen ingebouwde asynchrone runtime 1. Daarentegen heeft Rust wel ingebouwde tools async/.await om asynchrone functies te schrijven die lijken op synchrone functies.\nWanneer je async toevoegt aan een code block of functie dan wordt die code een state machine die de Future trait implementeert. Deze code retourneert ook een Future en je moet deze code dan laten uitvoeren door een excecutor.\nBinnen een async functie of codeblok kun je .await gebruiken op een andere Future. Dit instrueert het programma om te wachten tot de Future is voltooid. Een cruciaal kenmerk van .await is dat het de uitvoerende thread niet blokkeert, waardoor de runtime andere taken kan uitvoeren tijdens het wachten. Dit efficiënte gebruik van bronnen maakt Rust bijzonder geschikt voor I/O-intensieve toepassingen en taken met veel gelijktijdige operaties.\nDit voorbeeld (hieronder) demonstreert het gebruik van async/.await in Rust met de Tokio runtime. Het illustreert een belangrijk voordeel van asynchrone programmering: het gelijktijdig uitvoeren van meerdere taken. Terwijl de uitvoering van taak 1 wordt uitgesteld – bijvoorbeeld tijdens het wachten op een netwerkverzoek – kan taak 2 alvast worden uitgevoerd. Dit aspect van asynchroniteit zorgt ervoor dat je programma efficiënt blijft draaien, zelfs wanneer bepaalde operaties vertraging ondervinden.\nuse tokio::time::{sleep, Duration};\n#[tokio::main]\nasync fn main() {\n    println!(\"Taak starten...\");\n    let task1 = tokio::spawn(my_async_function());\n    let task2 = tokio::spawn(another_async_function());\n\n    // Wacht op beide taken om te voltooien\n    task1.await.expect(\"Taak 1 faalde\");\n    task2.await.expect(\"Taak 2 faalde\");\n    println!(\"Beide taken voltooid.\");\n}\n\nasync fn my_async_function() {\n    println!(\"Begin van de asynchrone taak 1.\");\n    sleep(Duration::from_secs(2)).await;\n    println!(\"Einde van de asynchrone taak 1.\");\n}\n\nasync fn another_async_function() {\n    println!(\"Begin van de asynchrone taak 2.\");\n    sleep(Duration::from_secs(1)).await;\n    println!(\"Einde van de asynchrone taak 2.\");\n}\nOutput:\nTaak starten...\nBegin van de asynchrone taak 1.\nBegin van de asynchrone taak 2.\nEinde van de asynchrone taak 2.\nEinde van de asynchrone taak 1.\nBeide taken voltooid."
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#het-maken-van-discord-bots-met-poise",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#het-maken-van-discord-bots-met-poise",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Het maken van Discord bots met Poise",
    "text": "Het maken van Discord bots met Poise\nToen ik aan dit project begon, was ik van plan Serenity te gebruiken om een Discord Bot te maken. Dat werkte goed en ik had snel een eerste versie werkend, maar toen ik er een slash command van probeerde te maken, bleek dat minder eenvoudig dan verwacht. Gelukkig was ik niet de enige en daarom is de Poise crate gemaakt. Onder Poise wordt er nog steeds gebruik gemaakt van Serenity, maar het versimpelt het maken van slash commands enorm. Andere features die Poise heeft ingebouwd zijn:\n\n\nflexible argument parsing: command parameters are defined with normal Rust types and parsed automatically\ntext commands: commands are agnostic over old text-based commands and slash commands\nedit tracking: when user edits their message, automatically update bot response\n\n\nVervolgens heb je maar twee dingen nodig om met Poise een Discord Bot te maken, namelijk een Frameworken een slash-command.\n\nPoise framework\nHet Poise Framework is de manier om je bot te laten communiceren met de Discord API. En het gebruikt de Serenity client om een verbinding te maken met Discord. Daarnaast dien je hier de rest van de bot te configureren zoals welke commands je bot heeft.\n\n\nSlash command\nEen slash-command maak je simpelweg door deze attribute voor je functie te zetten:\n#[poise::command(slash_command)]\nMaar wat doet zo een attribuut?\nEen Rust attribute is een bijzondere functie, vind ik. Rust attributes zijn namelijk procedural macros (proc_macro). En wat een procedural macro zo bijzonder maakt, is dat het code uitvoert tijdens het compileren om zo de code tijdens het compileren aan te passen. Niet alleen Poise gebruikt het met bovenstaande poise::command(), maar ook Tokio maakt gebruik van procedural macros, namelijk voor de main functie. Tokio heeft in de [documentatie] een (mooi) voorbeeld van wat die procedural macro doet:\n#[tokio::main] \nasync fn main() { \n    println!(\"Hello world\"); \n}\nWordt:\nfn main() { \n    tokio::runtime::Builder::new_multi_thread() \n    .enable_all() \n    .build() \n    .unwrap() \n    .block_on(async { \n        println!(\"Hello world\"); \n    }) \n}\nHier zie je duidelijk dat een procedural macro de code direct verandert (zie onderaan de post, ter vergelijking, wat een Python decorator doet)."
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#alle-stukjes-bij-elkaar",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#alle-stukjes-bij-elkaar",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Alle stukjes bij elkaar",
    "text": "Alle stukjes bij elkaar\nNu alle puzzelstukjes zijn gesorteerd, kan de puzzel gelegd worden. Hieronder is een voorbeeld van een simpele, maar complete “hallo” Discord bot. Voel je vrij om de naam van de slash command aan te passen naar wat je maar wilt!\nuse poise::serenity_prelude as serenity;\nuse std::fs;\n\nstruct Data {}\ntype Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;\ntype Context&lt;'a&gt; = poise::Context&lt;'a, Data, Error&gt;;\n\n#[poise::command(slash_command)]\nasync fn hallo(ctx: Context&lt;'_&gt;) -&gt; Result&lt;(), Error&gt; {\n    ctx.say(\"Hallo\").await?;\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() {\n    let token = std::env::var(\"DISCORD_TOKEN\").expect(\"missing DISCORD_TOKEN\");\n    let intents = serenity::GatewayIntents::non_privileged();\n\n    let framework = poise::Framework::builder()\n    .token(token)\n    .intents(intents)\n    .options(poise::FrameworkOptions {\n        commands: vec![hallo()],\n        ..Default::default()\n    })\n    .setup(|ctx, _ready, framework| {\n        Box::pin(async move {\n            poise::builtins::register_globally(ctx, &framework.options().commands).await?;\n        Ok(Data {})\n        })\n    })\n    .build()\n    .await\n    .expect(\"Error creating framework\");\n\n  \n\n    if let Err(why) = framework.start().await {\n        println!(\"Client error: {:?}\", why);\n    }\n}\nVoordat je gaat, zijn hier nog een aantal zaken en benodigdheden om op te letten: 1. Je moet in Discord in een app maken met intents om berichten te mogen versturen en te ontvangen. Zie deze link voor meer informatie. 2. Je hebt een Discord Token nodig in je environment variabelen. In de link bij punt 1 staat deze informatie.\nNu ben je in staat om met Tokio en Poise een Discord bot te maken. Leef je uit :).\nVeel plezier.\nMees"
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#extra-informatie",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#extra-informatie",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Extra informatie",
    "text": "Extra informatie\nOm te begrijpen hoe Rust’s async/.await onder de moterkap werkt, zie deze link. Voor meer informatie over procedural macros, zie deze link. Discord maakt gebruikt van sharding als je bot in meer dan 2500 servers gebruikt wordt, zie deze link voor meer informatie over sharding."
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#python-decorator-en-rust-attribute-vergelijking",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#python-decorator-en-rust-attribute-vergelijking",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Python decorator en Rust attribute vergelijking",
    "text": "Python decorator en Rust attribute vergelijking\nVoor mij is Python een bekendere taal en daarom gebruik ik die taal ter vergelijking. En hoewel het niet exact hetzelfde is, vind ik het handig om de Rust attribute te vergelijken met een Python decorator. Dit omdat zowel de Rust attribute als Python Decorator een bestaande functie verrijken of aanpassen. Het grote verschil is de manier waarop de functie wordt aangepast.\nEen Python decorator is een “gewone” functie. Het argument van deze functie, is de functie die je decoreert. Bijvoorbeeld:\ndef print_info(func): \n    def wrapper(*args, **kwargs): \n        print(f\"Function {func.__name__} called with arguments {args} and keyword arguments {kwargs}\") \n        result = func(*args, **kwargs) \n        print(f\"Function returned {result}\") \n\n        return result \n\n    return wrapper \n\n@print_info \ndef add(a, b): \n    return a + b \n\nadd(3, 4)\nDe output van deze functie is:\nFunction add called with arguments (3, 4) and keyword arguments ()\nFunction returned 7"
  },
  {
    "objectID": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#footnotes",
    "href": "posts/2024-01-06-Minecraft-Bot-Rust-Deel-2/index.html#footnotes",
    "title": "Een Minecraft Discord Bot in Rust - Deel 2 - Het Verkennen van Asynchrone Discord Bots in Rust met Behulp van Poise en Tokio",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://rust-lang.github.io/async-book/01_getting_started/02_why_async.html#async-in-rust-vs-other-languages↩︎"
  },
  {
    "objectID": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html",
    "href": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html",
    "title": "Kwaadaardige moedervlekken herkennen met artificiële intelligentie",
    "section": "",
    "text": "Hoi hoi,\nVandaag wil ik een voorbeeld delen van Artificiële Intelligentie (AI) in de biologie. Maar voordat ik begin, een kleine waarschuwing. In deze post komen mogelijk onbekende en moeilijke termen voor. Wanneer ik ze allemaal in deze post uit ga leggen wordt de post ietwat lang. Daarom heb ik soms een korte uitleg gegeven ,maar op andere momenten niet ,want het idee is om deze termen uitvoerig te bespreken in de volgende posts. Dat gezegd hebbende, deze post gaat over mijn eerste project dat ik gemaakt heb, namelijk een model (eigenlijk een soort van computerprogramma) dat kan voorspellen of een moedervlek goed- of kwaadaardig is 1. Hiermee was ik begonnen ,omdat de (gratis!) online cursus van Fastai 2 aanbeveelt om zo snel mogelijk te experimenteren. Zo kan je spelenderwijs leren en later, mocht je het interessant vinden, dieper in de theorie duiken.\nOm het nog makkelijker te maken en sneller te kunnen beginnen met experimenteren heeft Fastai een eigen Python library (een term dat gebruikt wordt als: een uitbreiding van de programmeertaal Python). Met deze library, kun je met relatief weinig programmeerkennis een model trainen dat een voorspelling kan maken van, ja van wat niet eigenlijk. Dit kan zolang je maar genoeg voorbeelden (je data) hebt. Gelukkig hoef je niet altijd zelf je data te verzamelen, maar zijn er mensen die data gratis met de wereld delen. Tschandl et al.3 hebben plaatjes van moedervlekken bij elkaar gezocht en gelabeld (een label is de waarde die de data, in dit geval een foto, heeft). Specialisten op het gebied van moedervlekken hebben iedere foto beoordeeld als goed- of kwaadaardige moedervlek. Deze stap is erg belangrijk ,want zonder gelabelde data kun je eigenlijk geen AI model maken dat een nuttige voorspelling kan doen (met uitzondering van technieken die ongelabelde data gebruiken, maar dat is voor een volgende keer). En vaak geldt: des te meer data ,des te beter.\nNu we onze data hebben ,kunnen we bijna beginnen om een AI model te trainen. We hebben namelijk ook data nodig om ons model te evalueren. Hiervoor gebruik je data die niet is gebruikt tijdens het trainen. In de praktijk splits je daarom je data vaak in twee groepen. Een groep die je gebruikt om je model te trainen en een groep om te evalueren. Door deze splitsing evalueer je het getrainde model met data dat je model nog niet gezien heeft tijdens de training. Dat is erg belangrijk, want uiteindelijk wordt je model ook op deze manier gebruikt! Een foto die een gebruiker instuurt heeft het model nog nooit gezien en op deze foto’s wil je een accurate voorspelling doen.\nOk, nu kunnen we dan echt beginnen met het trainen van het model. Voor foto’s en plaatjes wordt (vaak) een speciale vorm model gebruikt, namelijk een convolutioneel neuraal netwerk (CNN; nog een term die ik later verder ga uitleggen, voor nu kan je een convolutie zien als een speciale rekensom). Zo ’n CNN gaan wij nu ook gebruiken (en de Fastai library maakt het ons erg gemakkelijk om dit te doen, maar de details bespreek ik weer later).\nTabel 1: Het trainen van een model. Epochs staat voor hoeveel keer je door je data heen gaat om je model te trainen. De train_loss is de loss die het model heeft op de trainingsdata en de valid_loss van je evaluatie data (hoe de loss wordt berekend ga ik later bespreken, de loss is berekend door het verschil tussen de voorspelde waarde door het model en de echte (gelabelde) waarde in een formule te stoppen). Als laatste bevat de tabel de tijd die 1 epoch duurt in minuten.\nIn onderstaande tabel zie je dat we (na maar een paar minuten trainen) een accuuraatheid van maarliefst 95% hebben (Tabel 1; De error rate is lager dan 0.05, wat betekent dat de accuraatheid groter is dan (1 - 0.05) * 100%). Dat is de kracht van transfer learning en trainen op een grafische kaart (GPU). Een wezenlijk probleem is echter dat de accuraatheid verbonden is aan of je model een soortgelijke moedervlek heeft gezien tijdens de training. Hoewel we dat probleem zo goed mogelijk proberen op te lossen door je data te splitsen, is het nog steeds een probleem wanneer een moedervlek er compleet anders uit ziet, dan de moedervlekken waarop je het model hebt getraind. Dat is een reden waarom deze modellen in de praktijk nog geen specialisten vervangen en waarom je dus met een gek uitziende moedervlek altijd naar een specialist moet gaan. Maar deze modellen kunnen wel als hulpmiddel dienen voor deze specialisten! Dit voorbeeld laat dus de kracht, maar zeker ook een grote uitdaging van AI zien.\nEr zijn veel voorbeelden waar soortgelijke technieken worden gebruikt (zie tabel 2). De code van dit project kan je vinden op Github en je kunt het getrainde model ook testen met een foto van een eigen moedervlek of eentje van het internet (moedervlek herkenner).\nTabel 2: Voorbeelden van andere projecten waarin biologische problemen worden opgelost met afbeeldingen.\nSoort Scan\nFunctie\nArtikel\n\n\n\n\n0\nMRI\nHersen Tumoren\nAli Işın, Cem Direkoğlu, Melike Şah, Review of MRI-based Brain Tumor Image Segmentation Using Deep Learning Methods, Procedia Computer Science, Volume 102,2016,Pages 317-324,ISSN 1877-0509,https://doi.org/10.1016/j.procs.2016.09.407.\n\n\n1\nH&E gekleurde cellen\nInfiltrerende lymfocyten in tumoren\nSpatial Organization and Molecular Correlation of Tumor-Infiltrating Lymphocytes Using Deep Learning on Pathology Images, Cell Reports, Volume 23, Issue 1, Pages 181-193.e7, ISSN 2211-1247, https://doi.org/10.1016/j.celrep.2018.03.086.\n\n\n2\nX-ray\nBorstkas aandoeningen\nHan Liu, Lei Wang, Yandong Nan, Faguang Jin, Qi Wang, Jiantao Pu, SDFN: Segmentation-based deep fusion network for thoracic disease classification in chest X-ray images, Computerized Medical Imaging and Graphics, Volume 75, Pages 66-73, ISSN 0895-6111, https://doi.org/10.1016/j.compmedimag.2019.05.005.\nWe zijn weer aan het einde gekomen en ik kan me goed voorstellen dat het duizelt van de moeilijke termen. Ik ga proberen om die termen in toekomstige berichten zo duidelijk mogelijk uit te leggen. Mochten er vragen of opmerkingen zijn, dan kunnen jullie die hieronder plaatsen! Bedankt voor het lezen en tot de volgende keer! (Smeer je goed in tegen de zon!!)."
  },
  {
    "objectID": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html#footnotes",
    "href": "posts/2021-06-19-Kwaadaardige-Moedervlekken/index.html#footnotes",
    "title": "Kwaadaardige moedervlekken herkennen met artificiële intelligentie",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDit soort modellen zijn geen vervanging van een specialist. Wanneer je een rare (moeder)vlek hebt, raadpleeg altijd een dokter.↩︎\nFastai website↩︎\nTschandl, Philipp, 2018, The HAM10000 dataset, a large collection of multi-source dermatoscopic images of common pigmented skin lesions, https://doi.org/10.7910/DVN/DBW86T, Harvard Dataverse, V3↩︎"
  },
  {
    "objectID": "posts/2022-07-13-Tussenproject-Tour-De-France-Voorspellen/index.html",
    "href": "posts/2022-07-13-Tussenproject-Tour-De-France-Voorspellen/index.html",
    "title": "Tussenproject - Tour de France Voorpspellen met Machine Learning",
    "section": "",
    "text": "Het jaarlijkse wielerspektakel de Tour de France staat weer voor de deur! Dat betekent ook dat ik renners mag gaan kiezen voor de eveneens jaarlijks terugkerende Wielerpoule (in het kort, je kiest een aantal wielrenners die mee gaan doen met de Tour en op basis van hun uitslag haal je punten). Nu heb ik de laatste jaren het wielrennen niet tot nauwelijks gevolgd waardoor ik geen idee heb welke renners er in vorm zijn. Daarom heb ik weer besloten om mijn programmeer en machine learning (ML) vaardigheden te gebruiken. Hiermee hoop ik het beste team samen te stellen. Als eerste hebben we data nodig om de beste renners te kunnen voorspellen en gelukkig is er een mooie website waar wij die data vanaf kunnen halen!\n\nData van een website halen\nOm met Python data van een website te halen heb je verschillende Python packages ter beschikking. Een van deze packages heb ik al vaker gebruikt en voor dit project ga ik dat weer gebruiken, BeautifulSoup (BS). Met BS kan je makkelijk navigeren door de HTML (opmaak) van een website en daarvandaan dan ook tekst ophalen. Maar dan moet je wel een website kunnen opvragen met coderen! Gelukkig kan dit ook met Python, namelijk met de requests package. In onderstaande code zie je een voorbeeld van hoe je een website in een BS object laad (zie hieronder).\n\n# Example: How to open a page using requests and BeautifulSoup\n\nrace_url = r\"https://www.procyclingstats.com/race/tour-de-france/2022/stage-4\"\n\n# Perform a get request on the url\nreq = requests.get(race_url)\n\n# Make a BeautifulSoup object from the requests's text\nsoup = BeautifulSoup(req.text, \"lxml\")\n\n# Get the title of the page\nprint(soup.find('title').string)\n\nFeatureNotFound: Couldn't find a tree builder with the features you requested: lxml. Do you need to install a parser library?\n\n\nVervolgens kan je ingebouwde methodes van het BS object gebruiken om door de HTML te zoeken. Zelf kijk ik eerst in de internet browser naar de elementen van de website waarvan ik de data wil. Afhankelijk van de browser die je gebruikt kan je elementen inspecteren. Ik let daarbij op het het HTML type (div, table, etc) en of het een class of id heeft. Met deze informatie kan je dan een specifiek element zoeken, zoals de top-20 van een uitslag (zie hieronder).\n\n# Example: Getting the top-20 results of a race\n\nrace_url = r\"https://www.procyclingstats.com/race/tour-de-france/2022/stage-4\"\n\n# Perform a get request on the url\nreq = requests.get(race_url)\n\n# Make a BeautifulSoup object from the requests's text\nsoup = BeautifulSoup(req.text, \"lxml\")\n\n# I used the browser to find the element we are interested in\nresult_list = soup.find(\"table\", class_=\"results basic moblist10\").find(\"tbody\")\n\n# Each result is in a table row (tr)\nresults = result_list.find_all(\"tr\")\n\nrace_top_20 = {}\n\nfor i in range(20):\n    result = results[i]\n    \n    # Again, use your browser to find the element you are interested in\n    rider = result.find_all(\"a\")[0].text\n    \n    race_top_20[i + 1] = rider \n    \npprint.pprint(race_top_20)\n\nFeatureNotFound: Couldn't find a tree builder with the features you requested: lxml. Do you need to install a parser library?\n\n\n\n\nDe opgehaalde data\nIn totaal had ik deze data opgehaald: * Van de Tour de France van 2000 - 2021 alle renners die mee deden * Via al die renners, voor ieder jaar, de races en eindklassering URLs * Voor alle renners de geboortedatum, de teams en de PCS score (de laatste twee voor ieder jaar) * Voor iedere race de datum, top-20 en de gemiddelde PCS score van de top-20\nNadat al deze data is verzameld kunnen we deze data gebruiken om de features te gaan maken waarmee je een ML model kunt trainen.\n\n\nFeatures maken\nEen feature is een deel van de totale informatie waarmee je een voorspelling kunt maken. Bijvoorbeeld, wanneer je iemands gewicht wilt voorspellen aan de hand van iemands lengte, dan is lengte je feature (zie grafiek hieronder). Hoewel het verband tussen gewicht en lengte niet 1 op 1 is zijn over het algemeen lange mensen zwaarder dan kleine mensen. Een andere feature die je dan zou kunnen toevoegen om je voorspelling te verbeteren is bijvoorbeeld het aantal uren sporten per week. Samen met de lengte zal dit betere voorspellingen geven omdat (vaak) wanneer je meer sport je geen uitschieter hebt in gewicht (een nogal grove aanname). Zoals je misschien merkt kan je vele features bedenken en daarom heb je zeker een mate van creativiteit nodig!\n\n\n                                                \n\n\n\ndata van: https://www.tno.nl/groei\n\nTwee jaar geleden (v1) had ik ook een ML model gemaakt maar dit keer wilde ik nieuwe features gebruiken. In V1 had ik het idee om de races op te delen in types (vlak, heuvelachtig met vlakke finish, heuvelachtig met finish bergop, gebergte met vlakke finish en gebergte met finish bergop; Voor de races waar dit niet voor bekend was had ik zelfs een model getraind om dat te voorspellen). Vervolgens had ik voor iedere types de plekken 1 t/m 4, 5 t/m 8 en 9 t/m 12 ingedeeld (zie Tabel hieronder). Voor iedere renner telde ik dan in het voorgaande jaar hoe vaak iemand deze uitslag in deze type had (zie voorbeeld van Chris Froome hieronder). Hoewel ik best tevreden was met deze features, namen ze niet mee hoe sterk het deelnemersveld was. Wanneer je veel wint maar je tegenstand niet heel sterk is, is deze overwinning minder relevant (weer een grove aanname) in de Tour, want in de Tour is het deelnemersveld vaak erg sterk. Daarom heb ik voor deze Tour de France nieuwe features bedacht.\n\n\n\nFeatures\nChris Froome\n\n\n\n\nPCS\n1377\n\n\nTeam PCS\n4172\n\n\nAge\n29\n\n\nflat1-4\n1.0\n\n\nflat5-8\n0.0\n\n\nflat9-12\n2.0\n\n\nhills(flat)1-4\n1.0\n\n\nhills(flat)5-8\n0.0\n\n\nhills(flat)9-12\n1.0\n\n\nhills(uphill)1-4\n2.0\n\n\nhills(uphill)5-8\n1.0\n\n\nhills(uphill)9-12\n1.0\n\n\nmountains(flat)1-4\n1.0\n\n\nmountains(flat)5-8\n0.0\n\n\nmountains(flat)9-12\n1.0\n\n\nmountains(uphill)1-4\n4.0\n\n\nmountains(uphill)5-8\n5.0\n\n\nmountains(uphill)9-12\n1.0\n\n\ngc1-4\n3.0\n\n\ngc5-8\n1.0\n\n\ngc9-12\n1.0\n\n\n\nVoor deze Tour nemen we bij iedere rit dus de sterkte van het deelnemersveld mee. Dat doen we door de gemiddelde PCS score van de top-20 uit te rekenen. Vervolgens verdelen we de ritten in 5 kwantielen (zeer weinig competitief, weinig competitief, competitief, erg competitief en zeer erg competitief). En daarbij had ik dan dit keer de resultaten als volgt verdeeld: 1 t/m 5, 6 t/m 10, 11 t/m 15 en 16 t/m 20 (zie tabel met voorbeeld van Wout van Aert hieronder).\n\n\n\nFeatures\nWout van Aert\n\n\n\n\nPCS\n2820\n\n\nTeam PCS\n9724\n\n\nPCS ratio\n0.29\n\n\nAge\n27\n\n\ntop_5s_category_0\n0\n\n\ntop_10s_category_0\n0\n\n\ntop_15s_category_0\n0\n\n\ntop_20s_category_0\n0\n\n\ntop_5s_category_1\n0\n\n\ntop_10s_category_1\n0.0\n\n\ntop_15s_category_1\n0\n\n\ntop_20s_category_1\n0\n\n\ntop_5s_category_2\n2\n\n\ntop_10s_category_2\n0\n\n\ntop_15s_category_2\n0\n\n\ntop_20s_category_2\n0\n\n\ntop_5s_category_3\n1\n\n\ntop_10s_category_3\n1\n\n\ntop_15s_category_3\n0\n\n\ntop_20s_category_3\n0\n\n\ntop_5s_category_4\n11\n\n\ntop_10s_category_4\n2\n\n\ntop_15s_category_4\n2\n\n\ntop_20s_category_4\n0\n\n\ntop_5s_category_gc\n1.0\n\n\ntop_10s_category_gc\n0.0\n\n\ntop_15s_category_gc\n0\n\n\ntop_20s_category_gc\n0\n\n\n\nDaarnaast had ik nog een aantal renner specifieke features: leeftijd, PCS score, PCS punten van het team en PCS ratio (eigen PCS / team PCS). Nu hebben we alle features waarop we een ML model kunnen trainen!\n\n\nHet trainen van een model\nVoor data, zoals in dit project, in een tabel structuur is het meest gebruikte en vaak ook beste model een vorm van een gradient boosted tree. In het kort is een tree vaak verdeeld in een aantal ja/nee vragen. Een voorbeeld van een simpele tree is een decision tree (voorbeeld hieronder). Het idee van deze tree is in de loop van de tijd al meer uitgebreid, van random forests naar dus gradient boosted trees. Dit zijn (simpel en kort door de bocht) een verzameling van meerdere trees die na het trainen heel goed zijn om een voorspelling te maken. Een van mijn favoriete tree algoritmes is XGBoost en deze gaan we dan ook gebruiken!\n\nEen XGBoost model is redelijk makkelijk te trainen door (jawel alweer!) een Python package: XGBoost. Alhoewel, je hebt dan nog heel veel instellingen die kunt optimaliseren. Gelukkig heb je daar ook een goede bron voor, namelijk Gridsearch van Sklearn (alweer een package!). Wanneer je Gridsearch en XGBoost combineert kan je meerdere instellingen vergelijken en dan krijg je als resultaat de getrainde modellen (met de verschillende parameters). Je kunt dan zelfs het beste model met de beste instellingen opvragen! Ideaal en het voelt als magie!\n\n\nDe resultaten\nDe resultaten van het model zien er op het eerste gezicht niet raar uit (zie hieronder). De volgens Wielerpoule duurste renners zitten qua voorspelling bovenin. Met voor mij als opvallendste naam Vlasov (voor mij geen bekende naam maar de laatste tijd volg ik het wielrennen nauwelijks). Om mijn team samen te stellen heb ik de voorspelde punten gedeeld door de kosten. En daar heb ik, naast de top 4, mijn team mee opgevuld. Eens zien of we mee gaan spelen voor de prijzen!\n\n\n\n\nrider_name\nprediction\nprice\nscore_price_ratio\n\n\n\n\n\nVAN DER POEL Mathieu\n84.196594\n200\n0.420983\n\n\n\nVLASOV Aleksandr\n75.061699\n150\n0.500411\n\n\n\nPOGACAR Tadej\n70.501328\n200\n0.352507\n\n\n\nROGLIC Primož\n67.192093\n200\n0.335960\n\n\n\nVAN AERT Wout\n66.121864\n200\n0.330609\n\n\n\nMARTINEZ Daniel Felipe\n58.990757\n100\n0.589908\n\n\n\nVINGEGAARD Jonas\n57.898109\n150\n0.385987\n\n\n\nJAKOBSEN Fabio\n55.955868\n150\n0.373039\n\n\n\nKUNG Stefan\n55.773567\n100\n0.557736\n\n\n\nKRISTOFF Alexander\n54.939995\n100\n0.549400\n\n\n\nCOSNEFROY Benoit\n54.132721\n100\n0.541327\n\n\n\nPEDERSEN Mads\n50.576691\n100\n0.505767\n\n\n\nMOHORIC Matej\n50.398064\n100\n0.503981\n\n\n\nVAN BAARLE Dylan\n49.590599\n100\n0.495906\n\n\n\nHOFSTETTER Hugo\n49.079250\n100\n0.490793\n\n\n\nEWAN Caleb\n46.512360\n100\n0.465124\n\n\n\nLAPORTE Christophe\n44.920681\n100\n0.449207\n\n\n\nTEUNS Dylan\n44.595673\n100\n0.445957\n\n\n\nMCNULTY Brandon\n44.574734\n100\n0.445747\n\n\n\nPHILIPSEN Jasper\n44.041866\n100\n0.440419\n\n\n\nTot de volgende keer en veel plezier met het volgen van de Tour de France!\nMees\nP.S: De uiteindelijke dataset samen met de code voor het trainen van het ML model kan je vinden in deze Github repo.\nP.S 2: Tot dusver werkt het model (na ongeveer 1 week) redelijk. Helaas valt Mathieu van der Poel tegen (en die was het duurste)."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "",
    "text": "In deze blogpost ga ik uitleggen hoe je een command line interface (CLI) kunt maken met Rust. Rust heeft de laatste tijd mijn interesse gewekt en ik wil deze kennis uitbreiden door praktische projecten aan te pakken. Een van deze projecten is het ontwikkelen van een tool die een kennisbank van een GitHub-repository kan genereren voor gebruik in een Custom GPT. Hoewel OpenAI geen uitleg geeft over hoe de Custom GPT kennisbank werkt, vermoed ik dat het een mechanisme bevat vergelijkbaar met Retriever-Augmented Generation (RAG), wat ik ook zal toelichten."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#intro",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#intro",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "",
    "text": "In deze blogpost ga ik uitleggen hoe je een command line interface (CLI) kunt maken met Rust. Rust heeft de laatste tijd mijn interesse gewekt en ik wil deze kennis uitbreiden door praktische projecten aan te pakken. Een van deze projecten is het ontwikkelen van een tool die een kennisbank van een GitHub-repository kan genereren voor gebruik in een Custom GPT. Hoewel OpenAI geen uitleg geeft over hoe de Custom GPT kennisbank werkt, vermoed ik dat het een mechanisme bevat vergelijkbaar met Retriever-Augmented Generation (RAG), wat ik ook zal toelichten."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#een-cli-in-rust",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#een-cli-in-rust",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "Een CLI in Rust",
    "text": "Een CLI in Rust\nZoals ik in een vorige post al benadrukte, biedt Rust talrijke voordelen voor het ontwikkelen van software en dit geldt ook voor het maken van een CLI. Een specifiek voordeel voor het bouwen van CLI’s in Rust zijn de fantastische ‘crates’ die beschikbaar zijn voor het bouwen van een CLI. Voor dit project wordt gebruikgemaakt van de Clap-crate.\nClap biedt twee stijlen om je CLI te definiëren: via de derive en builder. In de documentatie van Clap wordt aangeraden om derive te gebruiken vanwege de eenvoudige lees- en schrijfbaarheid. In deze post zullen we ook derive gebruiken, maar builder kan interessant zijn als je meer flexibiliteit nodig hebt."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#het-bouwen-van-een-github-repository-scraper-in-rust",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#het-bouwen-van-een-github-repository-scraper-in-rust",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "Het bouwen van een Github Repository Scraper in Rust",
    "text": "Het bouwen van een Github Repository Scraper in Rust\nHet eerste wat je maakt voor de CLI is een struct met Parser in de derive, waarin je de CLI-argumenten definieert die je aan je CLI kunnen worden meegegeven. Een voorbeeld is het argument github_url om aan te geven welke GitHub-repository je wilt scrapen. Clap biedt veel configuratie mogelijkheden, zoals:\n\nOptionele argumenten\nKorte argumenten\nEnum-waarden met standaardwaardes\n\nDe huidige configuratie van de Repo Harvest CLI bevat een voorbeeld van een aantal van die mogelijkheden (zie hieronder).\n#[derive(Parser, Debug)]\nstruct Cli {\n    /// The Github URL of the repository you want to fetch\n    github_url: String,\n    /// Exclude pattern\n    #[clap(short = 'e', long)]\n    exclude: Option&lt;String&gt;,\n    /// Include pattern\n    #[clap(short = 'p', long)]\n    include: Option&lt;String&gt;,\n    /// Output format\n    /// Can be one of, json, markdown\n    #[clap(\n        short = 'f',\n        long,\n        value_enum,\n        rename_all = \"kebab-case\",\n        default_value = \"json\"\n    )]\n    format: OutputFormat,\n    /// Include hidden files\n    /// By default, hidden files are not included\n    /// If you want to include hidden files, set this flag to true\n    #[clap(short = 'i', long, default_value = \"false\")]\n    hidden: Option&lt;bool&gt;,\n    /// The output file\n    #[clap(short, long, default_value = \"output\")]\n    output_file: String,\n}\nNa het definiëren van de argument in de struct, is het implementeren van de main() functie. Hierin kan je door de gebruiker ingevulde argumenten gebruiken om de code-flow van de CLI te sturen.\nJe kunt de argumenten op de volgende manier gebruiken:\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"{:?}\", &args.github_url);\n\n    match cli.github_url {\n        Some(url) =&gt; {\n            println!(\"Scraping repository at: {}\", url);\n        },\n        None =&gt; println!(\"No GitHub URL provided.\"),\n    }\n}\nEn wat je dan verder in de main() functie doet mag je zelf bepalen ;). Maar voor een voorbeeld kan je hier kijken hoe ik de scraper geïmplementeerd heb."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#introductie-tot-custom-gpts",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#introductie-tot-custom-gpts",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "Introductie tot Custom GPT’s",
    "text": "Introductie tot Custom GPT’s\nSinds november 2023 heb je de mogelijkheid om Custom GPT’s te maken (met ChatGPT Plus). Hierin kan je instructies, extra kennis en acties geven. Een voordeel hiervan is dat je niet steeds je prompt hoeft te herhalen. Bijvoorbeeld: ik vraag ChatGPT vaak Rust gerelateerde vragen en dan begin ik met een prompt zoals deze: “Hey ChatGPT, jij bent een senior Rust programmeur en ik een junior. Wanneer ik je code stuur, geef jij de verbeterde code terug met aanwijzingen waarom het beter is.” Met een Custom GTP kan je deze prompt eenmalig invoeren en vervolgens direct beginnen met het indienen van mijn code, wat tijd bespaart en de interactie efficiënter maakt.\nDaarnaast kan je extra kennis toevoegen en daar wil ik de repo harvester voor gebruiken. Het idee is dat de algemene Rust skills van ChatGPT best aardig zijn, maar soms wil je specifieke vragen stellen over een bepaalde crate. Met de repo harvester kan je de code van een crate ophalen en dat toevoegen aan je Custom GPT. Hierdoor kan je specifieke vragen stellen over de repository. Je kunt de Custom GPT dan gebruiken om te analyseren hoe je huidige code zich verhoudt tot die in de crate en om suggesties te vragen hoe je je code kan verbeteren om meer te lijken op de best practices die in de crate worden gebruikt."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#hoe-gebruikt-chatgpt-de-extra-kennis",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#hoe-gebruikt-chatgpt-de-extra-kennis",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "Hoe gebruikt ChatGPT de extra kennis?",
    "text": "Hoe gebruikt ChatGPT de extra kennis?\nDe specifieke details over hoe ChatGPT de extra kennis gebruikt is niet beschikbaar, maar je kunt wel een gok doen. Er is een methode die vaak voor dit doeleinde wordt gebruikt, namelijk Retrieval-Augmented Generation (RAG). In het kort, RAG gebruikt jouw vraag om relevante documenten uit de kennisbank te zoeken. Vervolgens voegt hij jouw vraag en de stukken uit de kennisbank samen en dat geheel wordt opgestuurd naar ChatGPT (of een andere Large Language Model (LLM)). Met deze techniek kan je dus specifieke kennis mee geven aan ChatGPT. Maar hoe worden de relevante documenten precies geselecteerd?\nEr zijn verschillende technieken om RAG toe te passen maar vandaag ligt de focus op Naive Retrieval. Naive retrieval werkt door al de documenten om te zetten naar een numerieke representatie en dat op te slaan in een vector. In deze representatie zit gecomprimeerde informatie over de gehele inhoud van het document, wat haast als magie lijkt. Om dit verder toe te lichten is het makkelijker om bij losse woorden te blijven.\n\nEmbedding intermezzo\nWoorden dragen betekenis, en deze betekenissen kunnen ook numeriek uitgedrukt worden. Bijvoorbeeld, je gebruikt de dimensie Geslacht (de X-as) en je stelt dat mannelijk 1 is en vrouwelijk -1 is. Dan krijg opa de waarde 1, oma de waarde -1 en kleinkind de waarde 0, want dat is een neutraal woord (zie figuur hieronder voor het visuele voorbeeld).\n\n\n\nword embedding one axis\n\n\nMaar hier ontstaat een probleem: hoe kan je nu onderscheiden tussen een meisje en oma of een jongen en opa? Om deze nuances te kunnen vangen, kan je een extra dimensie toevoegen. Door een Y-as te introduceren die ‘leeftijd’ representeert, waarbij ‘oud’ als +1 wordt gedefinieerd en ‘jong’ als -1 (zie voorbeeld hieronder).\n\n\n\nword embedding two axis\n\n\nNu kan je de woorden onderscheiden door een numerieke representatie. Oma wordt [-1, 1] en baby [0, -1]. En zoals je je kunt voorstellen kan je meer en meer dimensies (assen) toevoegen om meer informatie op te slaan. Want als je nu puppie zou toevoegen zou die dezelfde representatie als baby hebben, terwijl het niet hetzelfde is. Dus dan zou je de ‘dier’ dimensie kunnen toevoegen. In LLM termen staan de numerieke representaties bekend als woord-embeddings.\nOm het makkelijk te houden hebben we woord-embeddings gebruikt, maar je kunt dit ook voor hele documenten doen (dit heet toepasselijk, document-embedding). Een voorbeeld van een dimensie, ook wel ‘feature’ genoemd, is het Onderwerp / Genre. Maar omdat een document meer informatie bevat, kunnen de features veel complexer zijn dan bij individuele woorden.\nHier zit ook weer een stukje magie, want als maker van een LLM specificeer je de features niet. De features worden door een LLM geleerd door te trainen op grote hoeveelheden tekst, waarbij ze leren om documenten die qua inhoud hetzelfde zijn of op elkaar lijken dicht bij elkaar in de embedding space (zoals het woord-embedding voorbeeld hierboven) te plaatsen. Wanneer de LLM dit geleerd heeft, kan je de LLM gebruiken om je knowledge base te embedden in de numerieke representatie.\n\nEen LLM bestaat uit meerdere onderdelen en de embedding laag is daar 1 van. Om dus een embedding te krijgen gebruik je alleen de embedding laag en niet het hele LLM. De functie van de LLM is namelijk het voorspellen van het volgende woord.\n\n\n\nNaive Retrieval\nMet de getrainde LLM hebben we een manier om de documenten om te zetten naar de numerieke representatie. En deze gebruik je in naive retrieval dan als volgt:\n\nDe gebruiker typt een vraag of stuk tekst naar de LLM\nDe input van de gebruiker wordt vertaald naar de numerieke representatie , of embedding, zoals eerder uitgelegd.\nMet deze numerieke waarde zoek je naar de numerieke waardes van de documenten in je kennisbank die daar het meeste op lijken (bijvoorbeeld de top 5, je hebt verschillende algoritmen om dat te berekenen, bijvoorbeeld Cosine Similarity (LINK))\nDe inhoud van de top 5 documenten voeg je toe aan de input van de gebruiker aan de LLM. Dus de LLM kan die specifieke informatie dan gebruiken.\nDe gebruiker krijgt een antwoord op basis van documenten.\n\nNaast naive retrieval zijn er nog complexere en mogelijk effectievere retrieval technieken. Voor een overzicht van deze technieken, kun je de artikelen hier en hier gebruiken."
  },
  {
    "objectID": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#conclusie",
    "href": "posts/2024-05-13-Custom-GPT-Rust-CLI/index.html#conclusie",
    "title": "Een Rust CLI maken om Custom GPTs te bouwen van een GitHub repository",
    "section": "Conclusie",
    "text": "Conclusie\nVan het maken van een CLI in Rust tot het begrijpen van de basisprincipes van embeddings en RAG. Nu heb je de kennis om een specifieke Custom GPT met eigen kennisbank te ontwikkelen. Waarom probeer je niet zelf een toepassing te bedenken, misschien zelfs met een simpele CLI? Je hebt nu de handvatten om te beginnen.\nSuccess en tot de volgende keer!\nMees"
  }
]